import BackToTop from "@/components/BackToTop";

# Deployment Strategy and Implementation

## Table of Contents

## Introduction

In this module, we'll implement a comprehensive deployment strategy for the online learning platform. We'll cover containerization with Docker, orchestration with Kubernetes, CI/CD pipelines, cloud deployment options, and production-ready configurations for scalability, security, and reliability.

## Deployment Architecture Overview

### Multi-Environment Strategy

1. **Development Environment**
   - Local development with Docker Compose
   - Hot reloading and debugging capabilities
   - Integrated testing environment

2. **Staging Environment**
   - Production-like environment for testing
   - Automated deployment from develop branch
   - Performance and load testing

3. **Production Environment**
   - High availability and scalability
   - Blue-green deployment strategy
   - Monitoring and alerting

## Containerization with Docker

### Backend Dockerfile

```dockerfile
# Multi-stage build for Spring Boot application
FROM maven:3.8.4-openjdk-17-slim AS builder

WORKDIR /app

# Copy pom.xml and download dependencies
COPY pom.xml .
RUN mvn dependency:go-offline -B

# Copy source code and build application
COPY src ./src
RUN mvn clean package -DskipTests

# Runtime stage
FROM openjdk:17-jre-slim

WORKDIR /app

# Create non-root user for security
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Install required packages
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy jar from builder stage
COPY --from=builder /app/target/online-learning-platform-*.jar app.jar

# Create logs directory
RUN mkdir -p /app/logs && chown -R appuser:appuser /app

# Switch to non-root user
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# Expose port
EXPOSE 8080

# JVM optimization for containers
ENV JAVA_OPTS="-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0 -XX:+UseG1GC -XX:+UseStringDeduplication"

# Run application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### Frontend Dockerfile

```dockerfile
# Multi-stage build for React application
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY yarn.lock ./

# Install dependencies
RUN yarn install --frozen-lockfile

# Copy source code
COPY . .

# Build application
RUN yarn build

# Production stage with Nginx
FROM nginx:alpine

# Copy custom nginx configuration
COPY nginx.conf /etc/nginx/nginx.conf

# Copy built application
COPY --from=builder /app/build /usr/share/nginx/html

# Copy SSL certificates (if using HTTPS)
COPY certs/ /etc/nginx/certs/

# Create non-root user
RUN addgroup -g 1001 -S nginx && \
    adduser -S -D -H -u 1001 -h /var/cache/nginx -s /sbin/nologin -G nginx -g nginx nginx

# Set permissions
RUN chown -R nginx:nginx /usr/share/nginx/html && \
    chown -R nginx:nginx /var/cache/nginx && \
    chown -R nginx:nginx /var/log/nginx && \
    chown -R nginx:nginx /etc/nginx/conf.d

# Switch to non-root user
USER nginx

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD wget --quiet --tries=1 --spider http://localhost:80/health || exit 1

# Expose port
EXPOSE 80 443

# Start Nginx
CMD ["nginx", "-g", "daemon off;"]
```

### Nginx Configuration

```nginx
# nginx.conf
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
    multi_accept on;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Logging format
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    # Performance optimizations
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 100M;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;

    # Security headers
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' https:; connect-src 'self' https:; media-src 'self' https:;";

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;

    # Upstream backend servers
    upstream backend {
        least_conn;
        server backend-1:8080 max_fails=3 fail_timeout=30s;
        server backend-2:8080 max_fails=3 fail_timeout=30s;
        server backend-3:8080 max_fails=3 fail_timeout=30s;
    }

    # Main server block
    server {
        listen 80;
        server_name localhost;
        root /usr/share/nginx/html;
        index index.html index.htm;

        # Health check endpoint
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }

        # API proxy
        location /api/ {
            limit_req zone=api burst=20 nodelay;

            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Timeouts
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;

            # Buffer settings
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
            proxy_busy_buffers_size 8k;
        }

        # Login endpoint with stricter rate limiting
        location /api/auth/login {
            limit_req zone=login burst=5 nodelay;
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Static files with caching
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            add_header Vary Accept-Encoding;
        }

        # SPA fallback
        location / {
            try_files $uri $uri/ /index.html;
            add_header Cache-Control "no-cache, no-store, must-revalidate";
            add_header Pragma "no-cache";
            add_header Expires "0";
        }

        # Security - deny access to hidden files
        location ~ /\. {
            deny all;
            access_log off;
            log_not_found off;
        }
    }

    # HTTPS server block (for production)
    server {
        listen 443 ssl http2;
        server_name your-domain.com;
        root /usr/share/nginx/html;
        index index.html;

        # SSL configuration
        ssl_certificate /etc/nginx/certs/fullchain.pem;
        ssl_certificate_key /etc/nginx/certs/privkey.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;

        # OCSP stapling
        ssl_stapling on;
        ssl_stapling_verify on;

        # Same location blocks as HTTP server...
    }
}
```

### Docker Compose for Development

```yaml
# docker-compose.yml
version: "3.8"

services:
  # MongoDB database
  mongodb:
    image: mongo:6.0
    container_name: learning-platform-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password123
      MONGO_INITDB_DATABASE: learning_platform
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
      - ./mongo-init:/docker-entrypoint-initdb.d
    networks:
      - learning-platform-network

  # Redis for caching and sessions
  redis:
    image: redis:7-alpine
    container_name: learning-platform-redis
    restart: unless-stopped
    command: redis-server --requirepass password123
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - learning-platform-network

  # Backend application
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: learning-platform-backend
    restart: unless-stopped
    environment:
      SPRING_PROFILES_ACTIVE: docker
      MONGODB_URI: mongodb://admin:password123@mongodb:27017/learning_platform?authSource=admin
      REDIS_HOST: redis
      REDIS_PASSWORD: password123
      JWT_SECRET: your-jwt-secret-key-here
      FILE_STORAGE_PATH: /app/uploads
    ports:
      - "8080:8080"
    volumes:
      - backend_uploads:/app/uploads
      - backend_logs:/app/logs
    depends_on:
      - mongodb
      - redis
    networks:
      - learning-platform-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # Frontend application
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: learning-platform-frontend
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - backend
    networks:
      - learning-platform-network
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--quiet",
          "--tries=1",
          "--spider",
          "http://localhost:80/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3

  # Elasticsearch for search functionality
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.8.0
    container_name: learning-platform-elasticsearch
    restart: unless-stopped
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ports:
      - "9200:9200"
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    networks:
      - learning-platform-network

  # Nginx reverse proxy (for production-like setup)
  nginx:
    image: nginx:alpine
    container_name: learning-platform-nginx
    restart: unless-stopped
    ports:
      - "8000:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - frontend
      - backend
    networks:
      - learning-platform-network

volumes:
  mongodb_data:
  redis_data:
  elasticsearch_data:
  backend_uploads:
  backend_logs:

networks:
  learning-platform-network:
    driver: bridge
```

## Kubernetes Deployment

### Namespace and ConfigMap

```yaml
# k8s/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: learning-platform
  labels:
    name: learning-platform

---
# k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: learning-platform-config
  namespace: learning-platform
data:
  # Application configuration
  SPRING_PROFILES_ACTIVE: "production"
  MONGODB_DATABASE: "learning_platform"
  REDIS_DB: "0"
  LOG_LEVEL: "INFO"

  # Performance settings
  JVM_OPTS: "-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0 -XX:+UseG1GC"

  # Feature flags
  ENABLE_CACHING: "true"
  ENABLE_METRICS: "true"
  ENABLE_TRACING: "true"

---
# k8s/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: learning-platform-secrets
  namespace: learning-platform
type: Opaque
data:
  # Base64 encoded values
  MONGODB_USERNAME: YWRtaW4= # admin
  MONGODB_PASSWORD: cGFzc3dvcmQxMjM= # password123
  REDIS_PASSWORD: cGFzc3dvcmQxMjM= # password123
  JWT_SECRET: eW91ci1qd3Qtc2VjcmV0LWtleS1oZXJl # your-jwt-secret-key-here
  EMAIL_PASSWORD: ZW1haWwtcGFzc3dvcmQ= # email-password
```

### Database Deployments

```yaml
# k8s/mongodb.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mongodb
  namespace: learning-platform
spec:
  serviceName: mongodb-service
  replicas: 3
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
        - name: mongodb
          image: mongo:6.0
          ports:
            - containerPort: 27017
          env:
            - name: MONGO_INITDB_ROOT_USERNAME
              valueFrom:
                secretKeyRef:
                  name: learning-platform-secrets
                  key: MONGODB_USERNAME
            - name: MONGO_INITDB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: learning-platform-secrets
                  key: MONGODB_PASSWORD
          volumeMounts:
            - name: mongodb-storage
              mountPath: /data/db
          resources:
            requests:
              memory: "1Gi"
              cpu: "500m"
            limits:
              memory: "2Gi"
              cpu: "1000m"
          livenessProbe:
            exec:
              command:
                - mongo
                - --eval
                - "db.adminCommand('ismaster')"
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            exec:
              command:
                - mongo
                - --eval
                - "db.adminCommand('ismaster')"
            initialDelaySeconds: 5
            periodSeconds: 5
  volumeClaimTemplates:
    - metadata:
        name: mongodb-storage
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: "fast-ssd"
        resources:
          requests:
            storage: 50Gi

---
apiVersion: v1
kind: Service
metadata:
  name: mongodb-service
  namespace: learning-platform
spec:
  clusterIP: None
  selector:
    app: mongodb
  ports:
    - port: 27017
      targetPort: 27017

---
# k8s/redis.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: learning-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
        - name: redis
          image: redis:7-alpine
          ports:
            - containerPort: 6379
          command:
            - redis-server
            - --requirepass
            - $(REDIS_PASSWORD)
          env:
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: learning-platform-secrets
                  key: REDIS_PASSWORD
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          livenessProbe:
            exec:
              command:
                - redis-cli
                - ping
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            exec:
              command:
                - redis-cli
                - ping
            initialDelaySeconds: 5
            periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: redis-service
  namespace: learning-platform
spec:
  selector:
    app: redis
  ports:
    - port: 6379
      targetPort: 6379
```

### Application Deployments

```yaml
# k8s/backend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: learning-platform
  labels:
    app: backend
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
        - name: backend
          image: learning-platform/backend:latest
          ports:
            - containerPort: 8080
          env:
            - name: MONGODB_URI
              value: "mongodb://$(MONGODB_USERNAME):$(MONGODB_PASSWORD)@mongodb-service:27017/learning_platform?authSource=admin"
            - name: MONGODB_USERNAME
              valueFrom:
                secretKeyRef:
                  name: learning-platform-secrets
                  key: MONGODB_USERNAME
            - name: MONGODB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: learning-platform-secrets
                  key: MONGODB_PASSWORD
            - name: REDIS_HOST
              value: "redis-service"
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: learning-platform-secrets
                  key: REDIS_PASSWORD
            - name: JWT_SECRET
              valueFrom:
                secretKeyRef:
                  name: learning-platform-secrets
                  key: JWT_SECRET
          envFrom:
            - configMapRef:
                name: learning-platform-config
          resources:
            requests:
              memory: "1Gi"
              cpu: "500m"
            limits:
              memory: "2Gi"
              cpu: "1000m"
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 2
          volumeMounts:
            - name: uploads-volume
              mountPath: /app/uploads
            - name: logs-volume
              mountPath: /app/logs
      volumes:
        - name: uploads-volume
          persistentVolumeClaim:
            claimName: backend-uploads-pvc
        - name: logs-volume
          emptyDir: {}

---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: learning-platform
spec:
  selector:
    app: backend
  ports:
    - port: 8080
      targetPort: 8080
  type: ClusterIP

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: backend-uploads-pvc
  namespace: learning-platform
spec:
  accessModes:
    - ReadWriteMany
  storageClassName: "fast-ssd"
  resources:
    requests:
      storage: 100Gi

---
# k8s/frontend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: learning-platform
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
        - name: frontend
          image: learning-platform/frontend:latest
          ports:
            - containerPort: 80
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "200m"
          livenessProbe:
            httpGet:
              path: /health
              port: 80
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: learning-platform
spec:
  selector:
    app: frontend
  ports:
    - port: 80
      targetPort: 80
  type: ClusterIP
```

### Ingress Configuration

```yaml
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: learning-platform-ingress
  namespace: learning-platform
  annotations:
    kubernetes.io/ingress.class: "nginx"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/use-regex: "true"
    nginx.ingress.kubernetes.io/rewrite-target: /$1
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
    nginx.ingress.kubernetes.io/client-body-buffer-size: "1m"
    nginx.ingress.kubernetes.io/proxy-body-size: "100m"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "30"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "30"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "30"
spec:
  tls:
    - hosts:
        - api.learning-platform.com
        - www.learning-platform.com
      secretName: learning-platform-tls
  rules:
    - host: api.learning-platform.com
      http:
        paths:
          - path: /(.*)
            pathType: Prefix
            backend:
              service:
                name: backend-service
                port:
                  number: 8080
    - host: www.learning-platform.com
      http:
        paths:
          - path: /api/(.*)
            pathType: Prefix
            backend:
              service:
                name: backend-service
                port:
                  number: 8080
          - path: /(.*)
            pathType: Prefix
            backend:
              service:
                name: frontend-service
                port:
                  number: 80

---
# k8s/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: backend-hpa
  namespace: learning-platform
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: backend
  minReplicas: 3
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 10
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
        - type: Percent
          value: 100
          periodSeconds: 60
        - type: Pods
          value: 2
          periodSeconds: 60

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: frontend-hpa
  namespace: learning-platform
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: frontend
  minReplicas: 2
  maxReplicas: 5
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
```

## CI/CD Pipeline

### GitHub Actions Workflow

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: ${{ github.repository }}/backend
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend

jobs:
  # Backend testing and building
  backend-ci:
    runs-on: ubuntu-latest
    services:
      mongodb:
        image: mongo:6.0
        env:
          MONGO_INITDB_ROOT_USERNAME: admin
          MONGO_INITDB_ROOT_PASSWORD: password123
        ports:
          - 27017:27017
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: "17"
          distribution: "temurin"

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Run tests
        working-directory: ./backend
        run: mvn test
        env:
          MONGODB_URI: mongodb://admin:password123@localhost:27017/test_db?authSource=admin
          REDIS_HOST: localhost
          REDIS_PORT: 6379

      - name: Run integration tests
        working-directory: ./backend
        run: mvn verify -P integration-tests
        env:
          MONGODB_URI: mongodb://admin:password123@localhost:27017/test_db?authSource=admin
          REDIS_HOST: localhost

      - name: Generate test report
        uses: dorny/test-reporter@v1
        if: success() || failure()
        with:
          name: Backend Tests
          path: backend/target/surefire-reports/*.xml
          reporter: java-junit

      - name: Build application
        working-directory: ./backend
        run: mvn clean package -DskipTests

      - name: Build Docker image
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
        working-directory: ./backend
        run: |
          docker build -t $REGISTRY/$IMAGE_NAME_BACKEND:${{ github.sha }} .
          docker build -t $REGISTRY/$IMAGE_NAME_BACKEND:latest .

      - name: Log in to Container Registry
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push Docker image
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
        run: |
          docker push $REGISTRY/$IMAGE_NAME_BACKEND:${{ github.sha }}
          docker push $REGISTRY/$IMAGE_NAME_BACKEND:latest

  # Frontend testing and building
  frontend-ci:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18"
          cache: "yarn"
          cache-dependency-path: frontend/yarn.lock

      - name: Install dependencies
        working-directory: ./frontend
        run: yarn install --frozen-lockfile

      - name: Run linting
        working-directory: ./frontend
        run: yarn lint

      - name: Run unit tests
        working-directory: ./frontend
        run: yarn test --coverage --watchAll=false

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./frontend/coverage/lcov.info
          flags: frontend

      - name: Build application
        working-directory: ./frontend
        run: yarn build

      - name: Run E2E tests
        working-directory: ./frontend
        run: |
          yarn start &
          sleep 30
          yarn cy:run

      - name: Build Docker image
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
        working-directory: ./frontend
        run: |
          docker build -t $REGISTRY/$IMAGE_NAME_FRONTEND:${{ github.sha }} .
          docker build -t $REGISTRY/$IMAGE_NAME_FRONTEND:latest .

      - name: Log in to Container Registry
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push Docker image
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
        run: |
          docker push $REGISTRY/$IMAGE_NAME_FRONTEND:${{ github.sha }}
          docker push $REGISTRY/$IMAGE_NAME_FRONTEND:latest

  # Security scanning
  security-scan:
    runs-on: ubuntu-latest
    needs: [backend-ci, frontend-ci]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: "trivy-results.sarif"

  # Deploy to staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [backend-ci, frontend-ci, security-scan]
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.28.0"

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy to staging
        run: |
          export KUBECONFIG=kubeconfig
          kubectl set image deployment/backend backend=$REGISTRY/$IMAGE_NAME_BACKEND:${{ github.sha }} -n learning-platform-staging
          kubectl set image deployment/frontend frontend=$REGISTRY/$IMAGE_NAME_FRONTEND:${{ github.sha }} -n learning-platform-staging
          kubectl rollout status deployment/backend -n learning-platform-staging
          kubectl rollout status deployment/frontend -n learning-platform-staging

      - name: Run smoke tests
        run: |
          export KUBECONFIG=kubeconfig
          # Wait for deployment to be ready
          kubectl wait --for=condition=available --timeout=300s deployment/backend -n learning-platform-staging
          kubectl wait --for=condition=available --timeout=300s deployment/frontend -n learning-platform-staging

          # Run smoke tests
          curl -f https://staging.learning-platform.com/api/health || exit 1
          curl -f https://staging.learning-platform.com/health || exit 1

  # Deploy to production
  deploy-production:
    runs-on: ubuntu-latest
    needs: [backend-ci, frontend-ci, security-scan]
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.28.0"

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Blue-Green Deployment
        run: |
          export KUBECONFIG=kubeconfig

          # Create green deployment
          kubectl apply -f k8s/backend-green.yaml
          kubectl apply -f k8s/frontend-green.yaml

          # Wait for green deployment to be ready
          kubectl rollout status deployment/backend-green -n learning-platform
          kubectl rollout status deployment/frontend-green -n learning-platform

          # Run health checks on green deployment
          kubectl port-forward service/backend-green-service 8080:8080 -n learning-platform &
          sleep 10
          curl -f http://localhost:8080/actuator/health || exit 1

          # Switch traffic to green
          kubectl patch service backend-service -p '{"spec":{"selector":{"version":"green"}}}' -n learning-platform
          kubectl patch service frontend-service -p '{"spec":{"selector":{"version":"green"}}}' -n learning-platform

          # Clean up blue deployment
          kubectl delete deployment backend-blue -n learning-platform --ignore-not-found=true
          kubectl delete deployment frontend-blue -n learning-platform --ignore-not-found=true

      - name: Post-deployment tests
        run: |
          # Wait for traffic switch
          sleep 30

          # Run comprehensive tests
          curl -f https://www.learning-platform.com/api/health || exit 1
          curl -f https://www.learning-platform.com/health || exit 1

          # Run load test
          kubectl apply -f k8s/load-test-job.yaml -n learning-platform
          kubectl wait --for=condition=complete job/load-test --timeout=600s -n learning-platform

  # Notification
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()

    steps:
      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: "#deployments"
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

### Deployment Scripts

```bash
#!/bin/bash
# scripts/deploy.sh

set -e

ENVIRONMENT=${1:-staging}
IMAGE_TAG=${2:-latest}
NAMESPACE="learning-platform-${ENVIRONMENT}"

echo "Deploying to ${ENVIRONMENT} environment..."

# Validate environment
if [[ "$ENVIRONMENT" != "staging" && "$ENVIRONMENT" != "production" ]]; then
    echo "Error: Environment must be 'staging' or 'production'"
    exit 1
fi

# Check if kubectl is configured
if ! kubectl cluster-info &> /dev/null; then
    echo "Error: kubectl is not configured or cluster is not accessible"
    exit 1
fi

# Create namespace if it doesn't exist
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# Apply configurations
echo "Applying configurations..."
kubectl apply -f k8s/configmap.yaml -n $NAMESPACE
kubectl apply -f k8s/secret.yaml -n $NAMESPACE

# Deploy databases
echo "Deploying databases..."
kubectl apply -f k8s/mongodb.yaml -n $NAMESPACE
kubectl apply -f k8s/redis.yaml -n $NAMESPACE

# Wait for databases to be ready
echo "Waiting for databases to be ready..."
kubectl wait --for=condition=ready pod -l app=mongodb --timeout=300s -n $NAMESPACE
kubectl wait --for=condition=ready pod -l app=redis --timeout=300s -n $NAMESPACE

# Deploy applications
echo "Deploying applications..."
kubectl set image deployment/backend backend=ghcr.io/learning-platform/backend:$IMAGE_TAG -n $NAMESPACE
kubectl set image deployment/frontend frontend=ghcr.io/learning-platform/frontend:$IMAGE_TAG -n $NAMESPACE

# Apply remaining configurations
kubectl apply -f k8s/backend.yaml -n $NAMESPACE
kubectl apply -f k8s/frontend.yaml -n $NAMESPACE
kubectl apply -f k8s/ingress.yaml -n $NAMESPACE
kubectl apply -f k8s/hpa.yaml -n $NAMESPACE

# Wait for deployments to be ready
echo "Waiting for deployments to be ready..."
kubectl rollout status deployment/backend -n $NAMESPACE --timeout=600s
kubectl rollout status deployment/frontend -n $NAMESPACE --timeout=600s

# Run health checks
echo "Running health checks..."
kubectl wait --for=condition=available deployment/backend -n $NAMESPACE --timeout=300s
kubectl wait --for=condition=available deployment/frontend -n $NAMESPACE --timeout=300s

# Test endpoints
BACKEND_URL=$(kubectl get ingress learning-platform-ingress -n $NAMESPACE -o jsonpath='{.spec.rules[0].host}')
FRONTEND_URL=$(kubectl get ingress learning-platform-ingress -n $NAMESPACE -o jsonpath='{.spec.rules[1].host}')

echo "Testing endpoints..."
curl -f "https://${BACKEND_URL}/actuator/health" || echo "Backend health check failed"
curl -f "https://${FRONTEND_URL}/health" || echo "Frontend health check failed"

echo "Deployment to ${ENVIRONMENT} completed successfully!"

# Print useful information
echo ""
echo "Deployment Information:"
echo "======================"
echo "Environment: ${ENVIRONMENT}"
echo "Namespace: ${NAMESPACE}"
echo "Backend URL: https://${BACKEND_URL}"
echo "Frontend URL: https://${FRONTEND_URL}"
echo "Image Tag: ${IMAGE_TAG}"
echo ""
echo "Useful commands:"
echo "kubectl get pods -n ${NAMESPACE}"
echo "kubectl logs -f deployment/backend -n ${NAMESPACE}"
echo "kubectl logs -f deployment/frontend -n ${NAMESPACE}"
```

### Rollback Script

```bash
#!/bin/bash
# scripts/rollback.sh

set -e

ENVIRONMENT=${1:-staging}
REVISION=${2}
NAMESPACE="learning-platform-${ENVIRONMENT}"

echo "Rolling back ${ENVIRONMENT} environment..."

if [[ -z "$REVISION" ]]; then
    echo "Rolling back to previous revision..."
    kubectl rollout undo deployment/backend -n $NAMESPACE
    kubectl rollout undo deployment/frontend -n $NAMESPACE
else
    echo "Rolling back to revision ${REVISION}..."
    kubectl rollout undo deployment/backend --to-revision=$REVISION -n $NAMESPACE
    kubectl rollout undo deployment/frontend --to-revision=$REVISION -n $NAMESPACE
fi

# Wait for rollback to complete
echo "Waiting for rollback to complete..."
kubectl rollout status deployment/backend -n $NAMESPACE --timeout=600s
kubectl rollout status deployment/frontend -n $NAMESPACE --timeout=600s

# Run health checks
echo "Running post-rollback health checks..."
kubectl wait --for=condition=available deployment/backend -n $NAMESPACE --timeout=300s
kubectl wait --for=condition=available deployment/frontend -n $NAMESPACE --timeout=300s

echo "Rollback completed successfully!"
```

## Key Deployment Features Implemented

1. **Containerization Strategy**
   - Multi-stage Docker builds for optimization
   - Security best practices with non-root users
   - Health checks and proper logging

2. **Kubernetes Orchestration**
   - High availability with multiple replicas
   - Auto-scaling based on CPU and memory
   - Rolling updates with zero downtime

3. **CI/CD Pipeline**
   - Comprehensive testing at each stage
   - Security scanning and vulnerability assessment
   - Blue-green deployment for production

4. **Production Readiness**
   - SSL/TLS termination and security headers
   - Load balancing and rate limiting
   - Monitoring and logging integration

5. **Operational Excellence**
   - Automated deployment and rollback scripts
   - Environment-specific configurations
   - Disaster recovery procedures

[← Previous: Testing](/proj-online-learning-platform-website/22-testing) | [Next: Monitoring & Analytics →](/proj-online-learning-platform-website/24-monitoring-analytics)

<BackToTop />
