# Module 11: Performance Optimization and Scaling

## Overview

This module focuses on optimizing performance and scaling strategies for the Lego e-commerce platform. You'll learn about caching, database optimization, CDN implementation, monitoring performance metrics, and horizontal/vertical scaling techniques to handle high traffic loads.

## Learning Objectives

- Implement comprehensive caching strategies
- Optimize database queries and indexing
- Configure Content Delivery Networks (CDN)
- Monitor and analyze performance metrics
- Implement horizontal and vertical scaling
- Optimize frontend performance
- Handle high-traffic scenarios and load balancing
- Implement auto-scaling policies

## Topics Covered

### 11.1 Caching Strategies

```python
# backend/apps/core/cache.py
from django.core.cache import cache
from django.conf import settings
from functools import wraps
import hashlib
import json
from typing import Any, Optional, Union

class CacheManager:
    """Centralized cache management with multiple strategies"""

    def __init__(self):
        self.default_timeout = getattr(settings, 'CACHE_DEFAULT_TIMEOUT', 300)
        self.redis_client = cache._cache.get_client()

    def get_cache_key(self, prefix: str, *args, **kwargs) -> str:
        """Generate consistent cache keys"""
        key_data = f"{prefix}:{':'.join(map(str, args))}"
        if kwargs:
            key_data += f":{hashlib.md5(json.dumps(kwargs, sort_keys=True).encode()).hexdigest()}"
        return key_data

    def get(self, key: str, default: Any = None) -> Any:
        """Get value from cache"""
        return cache.get(key, default)

    def set(self, key: str, value: Any, timeout: Optional[int] = None) -> None:
        """Set value in cache"""
        timeout = timeout or self.default_timeout
        cache.set(key, value, timeout)

    def delete(self, key: str) -> None:
        """Delete key from cache"""
        cache.delete(key)

    def delete_pattern(self, pattern: str) -> None:
        """Delete keys matching pattern"""
        keys = self.redis_client.keys(pattern)
        if keys:
            self.redis_client.delete(*keys)

    def get_or_set(self, key: str, callable_func, timeout: Optional[int] = None) -> Any:
        """Get from cache or set if not exists"""
        value = self.get(key)
        if value is None:
            value = callable_func()
            self.set(key, value, timeout)
        return value

cache_manager = CacheManager()

def cached_view(timeout: int = 300, key_prefix: str = ''):
    """Decorator for caching view responses"""
    def decorator(view_func):
        @wraps(view_func)
        def wrapper(request, *args, **kwargs):
            # Generate cache key based on URL, query params, and user
            cache_key = cache_manager.get_cache_key(
                f"view:{key_prefix}:{view_func.__name__}",
                request.path,
                request.GET.urlencode(),
                request.user.id if request.user.is_authenticated else 'anonymous'
            )

            response = cache_manager.get(cache_key)
            if response is None:
                response = view_func(request, *args, **kwargs)
                cache_manager.set(cache_key, response, timeout)

            return response
        return wrapper
    return decorator

def cached_property(timeout: int = 300):
    """Decorator for caching model properties"""
    def decorator(func):
        @wraps(func)
        def wrapper(self):
            cache_key = cache_manager.get_cache_key(
                f"property:{self.__class__.__name__}",
                self.pk,
                func.__name__
            )

            value = cache_manager.get(cache_key)
            if value is None:
                value = func(self)
                cache_manager.set(cache_key, value, timeout)

            return value
        return wrapper
    return decorator

# backend/apps/products/models.py
from django.db import models
from django.core.cache import cache
from apps.core.cache import cache_manager, cached_property

class ProductManager(models.Manager):
    def get_featured_products(self):
        """Get featured products with caching"""
        cache_key = "products:featured"
        featured = cache_manager.get(cache_key)

        if featured is None:
            featured = list(self.filter(
                is_featured=True,
                is_active=True,
                stock_quantity__gt=0
            ).select_related('category').prefetch_related('images')[:12])
            cache_manager.set(cache_key, featured, 3600)  # Cache for 1 hour

        return featured

    def get_bestsellers(self):
        """Get bestselling products with caching"""
        cache_key = "products:bestsellers"
        bestsellers = cache_manager.get(cache_key)

        if bestsellers is None:
            bestsellers = list(self.filter(
                is_active=True,
                stock_quantity__gt=0
            ).annotate(
                total_sold=models.Sum('orderitem__quantity')
            ).order_by('-total_sold')[:20])
            cache_manager.set(cache_key, bestsellers, 7200)  # Cache for 2 hours

        return bestsellers

class Product(models.Model):
    # ... existing fields ...

    objects = ProductManager()

    @cached_property(timeout=1800)  # 30 minutes
    def average_rating(self):
        """Calculate average rating with caching"""
        from django.db.models import Avg
        result = self.reviews.aggregate(avg_rating=Avg('rating'))
        return round(result['avg_rating'] or 0, 2)

    @cached_property(timeout=3600)  # 1 hour
    def review_count(self):
        """Get review count with caching"""
        return self.reviews.filter(is_approved=True).count()

    def save(self, *args, **kwargs):
        """Clear related caches on save"""
        super().save(*args, **kwargs)

        # Clear product-specific caches
        cache_patterns = [
            f"products:featured",
            f"products:bestsellers",
            f"product:{self.pk}:*",
            f"category:{self.category_id}:*",
        ]

        for pattern in cache_patterns:
            cache_manager.delete_pattern(pattern)

# backend/apps/products/views.py
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
from django.views.decorators.vary import vary_on_headers
from apps.core.cache import cached_view, cache_manager

class ProductViewSet(viewsets.ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    @method_decorator(cache_page(60 * 15))  # Cache for 15 minutes
    @method_decorator(vary_on_headers('User-Agent', 'Accept-Language'))
    def list(self, request, *args, **kwargs):
        """List products with caching"""
        return super().list(request, *args, **kwargs)

    @action(detail=False, methods=['get'])
    @cached_view(timeout=3600, key_prefix='featured')
    def featured(self, request):
        """Get featured products"""
        products = Product.objects.get_featured_products()
        serializer = self.get_serializer(products, many=True)
        return Response(serializer.data)

    @action(detail=False, methods=['get'])
    @cached_view(timeout=7200, key_prefix='bestsellers')
    def bestsellers(self, request):
        """Get bestselling products"""
        products = Product.objects.get_bestsellers()
        serializer = self.get_serializer(products, many=True)
        return Response(serializer.data)
```

### 11.2 Database Optimization

```python
# backend/apps/core/db_optimization.py
from django.db import models
from django.db.models import Prefetch, Q, F
from django.core.management.base import BaseCommand

class OptimizedQueryMixin:
    """Mixin for optimized database queries"""

    def get_optimized_queryset(self):
        """Get queryset with optimized select_related and prefetch_related"""
        queryset = self.get_queryset()

        # Add select_related for foreign keys
        if hasattr(self, 'select_related_fields'):
            queryset = queryset.select_related(*self.select_related_fields)

        # Add prefetch_related for many-to-many and reverse foreign keys
        if hasattr(self, 'prefetch_related_fields'):
            queryset = queryset.prefetch_related(*self.prefetch_related_fields)

        return queryset

# backend/apps/products/models.py
class ProductQuerySet(models.QuerySet):
    """Optimized queryset for products"""

    def with_category(self):
        """Include category data"""
        return self.select_related('category')

    def with_images(self):
        """Include product images"""
        return self.prefetch_related('images')

    def with_reviews(self):
        """Include reviews with user data"""
        return self.prefetch_related(
            Prefetch(
                'reviews',
                queryset=Review.objects.select_related('user').filter(is_approved=True)
            )
        )

    def active(self):
        """Filter active products"""
        return self.filter(is_active=True, stock_quantity__gt=0)

    def by_category(self, category_slug):
        """Filter by category"""
        return self.filter(category__slug=category_slug)

    def search(self, query):
        """Full-text search"""
        return self.filter(
            Q(name__icontains=query) |
            Q(description__icontains=query) |
            Q(category__name__icontains=query)
        )

    def with_stock(self):
        """Filter products with stock"""
        return self.filter(stock_quantity__gt=0)

    def best_sellers(self):
        """Get best selling products"""
        return self.annotate(
            total_sold=models.Sum('orderitem__quantity')
        ).filter(
            total_sold__gt=0
        ).order_by('-total_sold')

class ProductManager(models.Manager):
    def get_queryset(self):
        return ProductQuerySet(self.model, using=self._db)

    def active(self):
        return self.get_queryset().active()

    def with_details(self):
        """Get products with all related data"""
        return self.get_queryset().with_category().with_images().with_reviews()

# Database indexing
class Product(models.Model):
    name = models.CharField(max_length=200, db_index=True)
    slug = models.SlugField(unique=True, db_index=True)
    category = models.ForeignKey(Category, on_delete=models.CASCADE, db_index=True)
    price = models.DecimalField(max_digits=10, decimal_places=2, db_index=True)
    stock_quantity = models.PositiveIntegerField(db_index=True)
    is_active = models.BooleanField(default=True, db_index=True)
    is_featured = models.BooleanField(default=False, db_index=True)
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)

    objects = ProductManager()

    class Meta:
        indexes = [
            models.Index(fields=['category', 'is_active']),
            models.Index(fields=['is_featured', 'is_active']),
            models.Index(fields=['price', 'is_active']),
            models.Index(fields=['-created_at', 'is_active']),
            models.Index(fields=['name', 'category']),  # Composite index for search
        ]

# SQL query optimization
class OptimizedProductViewSet(viewsets.ModelViewSet):
    def get_queryset(self):
        """Optimized queryset based on action"""
        base_queryset = Product.objects.active()

        if self.action == 'list':
            # For list view, minimal data
            return base_queryset.with_category().only(
                'id', 'name', 'slug', 'price', 'thumbnail',
                'category__name', 'category__slug'
            )
        elif self.action == 'retrieve':
            # For detail view, full data
            return base_queryset.with_details()
        elif self.action in ['featured', 'bestsellers']:
            # For special views
            return base_queryset.with_category().with_images()

        return base_queryset

# Management command for database optimization
class Command(BaseCommand):
    help = 'Optimize database performance'

    def add_arguments(self, parser):
        parser.add_argument('--analyze', action='store_true', help='Analyze query performance')
        parser.add_argument('--vacuum', action='store_true', help='Vacuum database')
        parser.add_argument('--reindex', action='store_true', help='Rebuild indexes')

    def handle(self, *args, **options):
        from django.db import connection

        if options['analyze']:
            self.analyze_queries()

        if options['vacuum']:
            self.vacuum_database()

        if options['reindex']:
            self.rebuild_indexes()

    def analyze_queries(self):
        """Analyze slow queries"""
        with connection.cursor() as cursor:
            # PostgreSQL specific
            cursor.execute("""
                SELECT query, calls, total_time, mean_time
                FROM pg_stat_statements
                WHERE mean_time > 100
                ORDER BY mean_time DESC
                LIMIT 10
            """)

            for row in cursor.fetchall():
                self.stdout.write(f"Query: {row[0][:100]}...")
                self.stdout.write(f"Calls: {row[1]}, Mean time: {row[3]:.2f}ms")

    def vacuum_database(self):
        """Vacuum database tables"""
        with connection.cursor() as cursor:
            cursor.execute("VACUUM ANALYZE;")
        self.stdout.write("Database vacuumed successfully")

    def rebuild_indexes(self):
        """Rebuild database indexes"""
        with connection.cursor() as cursor:
            cursor.execute("REINDEX DATABASE legostore;")
        self.stdout.write("Indexes rebuilt successfully")
```

### 11.3 Frontend Performance Optimization

```typescript
// frontend/lib/performance.ts
import { useEffect, useCallback, useMemo } from 'react';

// Debounce hook for search
export const useDebounce = <T>(value: T, delay: number): T => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};

// Intersection Observer for lazy loading
export const useIntersectionObserver = (
  callback: () => void,
  options: IntersectionObserverInit = {}
) => {
  const [element, setElement] = useState<Element | null>(null);

  useEffect(() => {
    if (!element) return;

    const observer = new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting) {
        callback();
      }
    }, options);

    observer.observe(element);

    return () => observer.disconnect();
  }, [element, callback, options]);

  return setElement;
};

// Virtual scrolling hook
export const useVirtualList = <T>(
  items: T[],
  itemHeight: number,
  containerHeight: number
) => {
  const [scrollTop, setScrollTop] = useState(0);

  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    startIndex + Math.ceil(containerHeight / itemHeight),
    items.length - 1
  );

  const visibleItems = useMemo(() => {
    return items.slice(startIndex, endIndex + 1).map((item, index) => ({
      item,
      index: startIndex + index,
      offsetTop: (startIndex + index) * itemHeight,
    }));
  }, [items, startIndex, endIndex, itemHeight]);

  const totalHeight = items.length * itemHeight;

  return {
    visibleItems,
    totalHeight,
    setScrollTop,
  };
};

// frontend/components/LazyImage.tsx
import React, { useState, useRef, useEffect } from 'react';
import { useIntersectionObserver } from '@/lib/performance';

interface LazyImageProps {
  src: string;
  alt: string;
  placeholder?: string;
  className?: string;
}

export const LazyImage: React.FC<LazyImageProps> = ({
  src,
  alt,
  placeholder = '/placeholder.png',
  className,
}) => {
  const [loaded, setLoaded] = useState(false);
  const [inView, setInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  const setRef = useIntersectionObserver(
    () => setInView(true),
    { threshold: 0.1 }
  );

  useEffect(() => {
    if (imgRef.current) {
      setRef(imgRef.current);
    }
  }, [setRef]);

  useEffect(() => {
    if (inView && !loaded) {
      const img = new Image();
      img.onload = () => setLoaded(true);
      img.src = src;
    }
  }, [inView, src, loaded]);

  return (
    <img
      ref={imgRef}
      src={loaded ? src : placeholder}
      alt={alt}
      className={`transition-opacity duration-300 ${
        loaded ? 'opacity-100' : 'opacity-50'
      } ${className}`}
      loading="lazy"
    />
  );
};

// frontend/components/VirtualProductList.tsx
import React from 'react';
import { useVirtualList } from '@/lib/performance';

interface Product {
  id: string;
  name: string;
  price: number;
  image: string;
}

interface VirtualProductListProps {
  products: Product[];
  onProductClick: (product: Product) => void;
}

export const VirtualProductList: React.FC<VirtualProductListProps> = ({
  products,
  onProductClick,
}) => {
  const containerHeight = 600;
  const itemHeight = 120;

  const { visibleItems, totalHeight, setScrollTop } = useVirtualList(
    products,
    itemHeight,
    containerHeight
  );

  return (
    <div
      className="h-[600px] overflow-auto"
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div className="relative" style={{ height: totalHeight }}>
        {visibleItems.map(({ item, index, offsetTop }) => (
          <div
            key={item.id}
            className="absolute w-full flex items-center p-4 border-b cursor-pointer hover:bg-gray-50"
            style={{
              top: offsetTop,
              height: itemHeight,
            }}
            onClick={() => onProductClick(item)}
          >
            <LazyImage
              src={item.image}
              alt={item.name}
              className="w-16 h-16 object-cover rounded mr-4"
            />
            <div>
              <h3 className="font-medium">{item.name}</h3>
              <p className="text-green-600 font-bold">${item.price}</p>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

// frontend/hooks/useProductSearch.ts
import { useState, useEffect } from 'react';
import { useDebounce } from '@/lib/performance';
import { api } from '@/lib/api';

export const useProductSearch = () => {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const debouncedQuery = useDebounce(query, 300);

  useEffect(() => {
    if (!debouncedQuery.trim()) {
      setResults([]);
      return;
    }

    const searchProducts = async () => {
      setLoading(true);
      setError(null);

      try {
        const response = await api.get('/products/search/', {
          params: { q: debouncedQuery },
        });
        setResults(response.data.results);
      } catch (err) {
        setError('Search failed. Please try again.');
      } finally {
        setLoading(false);
      }
    };

    searchProducts();
  }, [debouncedQuery]);

  return {
    query,
    setQuery,
    results,
    loading,
    error,
  };
};
```

### 11.4 CDN and Static Asset Optimization

```typescript
// frontend/next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Image optimization
  images: {
    domains: [
      'cdn.legostore.com',
      'd1234567.cloudfront.net',
      'legostore-media.s3.amazonaws.com'
    ],
    formats: ['image/webp', 'image/avif'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },

  // Compression
  compress: true,

  // Bundle analyzer
  ...(process.env.ANALYZE === 'true' && {
    webpack: (config) => {
      config.plugins.push(
        new (require('@next/bundle-analyzer'))({
          enabled: true,
        })
      );
      return config;
    },
  }),

  // PWA configuration
  ...(process.env.NODE_ENV === 'production' && {
    swcMinify: true,
    experimental: {
      scrollRestoration: true,
    },
  }),

  // Static optimization
  experimental: {
    optimizeCss: true,
    optimizeImages: true,
  },

  // Headers for caching
  async headers() {
    return [
      {
        source: '/static/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
      {
        source: '/_next/image(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ];
  },
};

module.exports = nextConfig;

// frontend/lib/cdn.ts
export class CDNManager {
  private baseUrl: string;

  constructor() {
    this.baseUrl = process.env.NEXT_PUBLIC_CDN_URL || '';
  }

  getImageUrl(path: string, options: {
    width?: number;
    height?: number;
    quality?: number;
    format?: 'webp' | 'avif' | 'png' | 'jpg';
  } = {}) {
    if (!this.baseUrl) return path;

    const params = new URLSearchParams();

    if (options.width) params.set('w', options.width.toString());
    if (options.height) params.set('h', options.height.toString());
    if (options.quality) params.set('q', options.quality.toString());
    if (options.format) params.set('f', options.format);

    const queryString = params.toString();
    return `${this.baseUrl}${path}${queryString ? `?${queryString}` : ''}`;
  }

  preloadImage(src: string) {
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'image';
    link.href = src;
    document.head.appendChild(link);
  }

  preloadCriticalImages(images: string[]) {
    images.forEach(src => this.preloadImage(src));
  }
}

export const cdnManager = new CDNManager();

// frontend/components/OptimizedImage.tsx
import Image from 'next/image';
import { useState } from 'react';
import { cdnManager } from '@/lib/cdn';

interface OptimizedImageProps {
  src: string;
  alt: string;
  width: number;
  height: number;
  priority?: boolean;
  quality?: number;
  className?: string;
}

export const OptimizedImage: React.FC<OptimizedImageProps> = ({
  src,
  alt,
  width,
  height,
  priority = false,
  quality = 75,
  className,
}) => {
  const [imageError, setImageError] = useState(false);

  const optimizedSrc = cdnManager.getImageUrl(src, {
    width,
    height,
    quality,
    format: 'webp',
  });

  if (imageError) {
    return (
      <div
        className={`bg-gray-200 flex items-center justify-center ${className}`}
        style={{ width, height }}
      >
        <span className="text-gray-500">Image not available</span>
      </div>
    );
  }

  return (
    <Image
      src={optimizedSrc}
      alt={alt}
      width={width}
      height={height}
      priority={priority}
      quality={quality}
      className={className}
      onError={() => setImageError(true)}
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCdABmX/9k="
    />
  );
};
```

### 11.5 Monitoring and Performance Metrics

```python
# backend/apps/core/monitoring.py
import time
import logging
from functools import wraps
from django.conf import settings
from django.core.cache import cache
from prometheus_client import Counter, Histogram, Gauge
import psutil

# Prometheus metrics
request_count = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
request_duration = Histogram('http_request_duration_seconds', 'HTTP request duration')
active_connections = Gauge('active_database_connections', 'Active database connections')
cache_hit_rate = Gauge('cache_hit_rate', 'Cache hit rate percentage')
memory_usage = Gauge('memory_usage_bytes', 'Memory usage in bytes')
cpu_usage = Gauge('cpu_usage_percent', 'CPU usage percentage')

logger = logging.getLogger(__name__)

class PerformanceMonitoringMiddleware:
    """Middleware to monitor performance metrics"""

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        start_time = time.time()

        response = self.get_response(request)

        # Record metrics
        duration = time.time() - start_time
        request_duration.observe(duration)

        request_count.labels(
            method=request.method,
            endpoint=request.path,
            status=response.status_code
        ).inc()

        # Log slow requests
        if duration > 1.0:  # Log requests slower than 1 second
            logger.warning(
                f"Slow request: {request.method} {request.path} took {duration:.2f}s"
            )

        return response

def performance_monitor(threshold: float = 1.0):
    """Decorator to monitor function performance"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()

            try:
                result = func(*args, **kwargs)
                return result
            finally:
                duration = time.time() - start_time

                if duration > threshold:
                    logger.warning(
                        f"Slow function: {func.__name__} took {duration:.2f}s"
                    )

        return wrapper
    return decorator

class SystemMonitor:
    """Monitor system resources"""

    @staticmethod
    def update_system_metrics():
        """Update system metrics for Prometheus"""
        # Memory usage
        memory = psutil.virtual_memory()
        memory_usage.set(memory.used)

        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        cpu_usage.set(cpu_percent)

        # Database connections
        from django.db import connections
        for conn in connections.all():
            if hasattr(conn, 'queries_logged'):
                active_connections.set(len(conn.queries_logged))

    @staticmethod
    def calculate_cache_hit_rate():
        """Calculate and update cache hit rate"""
        hits = cache.get('cache_hits', 0)
        misses = cache.get('cache_misses', 0)

        if hits + misses > 0:
            hit_rate = (hits / (hits + misses)) * 100
            cache_hit_rate.set(hit_rate)

# Database query monitoring
class QueryMonitor:
    """Monitor database queries"""

    def __init__(self):
        self.slow_queries = []
        self.query_count = 0
        self.total_time = 0

    def log_query(self, query, duration):
        """Log query performance"""
        self.query_count += 1
        self.total_time += duration

        if duration > 0.5:  # Log slow queries (>500ms)
            self.slow_queries.append({
                'query': query[:200],  # Truncate long queries
                'duration': duration,
                'timestamp': time.time()
            })

            logger.warning(f"Slow query ({duration:.2f}s): {query[:100]}...")

    def get_stats(self):
        """Get query statistics"""
        avg_time = self.total_time / self.query_count if self.query_count > 0 else 0

        return {
            'total_queries': self.query_count,
            'total_time': self.total_time,
            'average_time': avg_time,
            'slow_queries': len(self.slow_queries)
        }

query_monitor = QueryMonitor()

# Performance testing utilities
class LoadTester:
    """Utility for load testing endpoints"""

    def __init__(self, base_url: str):
        self.base_url = base_url
        self.results = []

    async def test_endpoint(self, endpoint: str, concurrent_requests: int = 10):
        """Test endpoint with concurrent requests"""
        import aiohttp
        import asyncio

        async def make_request(session):
            start_time = time.time()
            try:
                async with session.get(f"{self.base_url}{endpoint}") as response:
                    await response.text()
                    duration = time.time() - start_time
                    return {
                        'status': response.status,
                        'duration': duration,
                        'success': True
                    }
            except Exception as e:
                return {
                    'status': 0,
                    'duration': time.time() - start_time,
                    'success': False,
                    'error': str(e)
                }

        async with aiohttp.ClientSession() as session:
            tasks = [make_request(session) for _ in range(concurrent_requests)]
            results = await asyncio.gather(*tasks)

        self.results.extend(results)
        return results

    def analyze_results(self):
        """Analyze load test results"""
        if not self.results:
            return {}

        successful_requests = [r for r in self.results if r['success']]
        failed_requests = [r for r in self.results if not r['success']]

        if successful_requests:
            durations = [r['duration'] for r in successful_requests]
            avg_duration = sum(durations) / len(durations)
            min_duration = min(durations)
            max_duration = max(durations)
        else:
            avg_duration = min_duration = max_duration = 0

        return {
            'total_requests': len(self.results),
            'successful_requests': len(successful_requests),
            'failed_requests': len(failed_requests),
            'success_rate': len(successful_requests) / len(self.results) * 100,
            'average_duration': avg_duration,
            'min_duration': min_duration,
            'max_duration': max_duration,
        }
```

### 11.6 Auto-scaling Configuration

```yaml
# k8s/autoscaling/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: backend-hpa
  namespace: lego-ecommerce
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: backend
  minReplicas: 3
  maxReplicas: 20
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
    - type: Pods
      pods:
        metric:
          name: http_requests_per_second
        target:
          type: AverageValue
          averageValue: "100"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 10
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
        - type: Percent
          value: 50
          periodSeconds: 60
        - type: Pods
          value: 2
          periodSeconds: 60

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: frontend-hpa
  namespace: lego-ecommerce
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: frontend
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 60
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 70

---
# k8s/autoscaling/vpa.yaml
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: backend-vpa
  namespace: lego-ecommerce
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: backend
  updatePolicy:
    updateMode: "Auto"
  resourcePolicy:
    containerPolicies:
      - containerName: backend
        maxAllowed:
          cpu: 2
          memory: 4Gi
        minAllowed:
          cpu: 100m
          memory: 256Mi

---
# k8s/autoscaling/cluster-autoscaler.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cluster-autoscaler
  namespace: kube-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cluster-autoscaler
  template:
    metadata:
      labels:
        app: cluster-autoscaler
    spec:
      serviceAccountName: cluster-autoscaler
      containers:
        - image: k8s.gcr.io/autoscaling/cluster-autoscaler:v1.21.0
          name: cluster-autoscaler
          resources:
            limits:
              cpu: 100m
              memory: 300Mi
            requests:
              cpu: 100m
              memory: 300Mi
          command:
            - ./cluster-autoscaler
            - --v=4
            - --stderrthreshold=info
            - --cloud-provider=aws
            - --skip-nodes-with-local-storage=false
            - --expander=least-waste
            - --node-group-auto-discovery=asg:tag=k8s.io/cluster-autoscaler/enabled,k8s.io/cluster-autoscaler/lego-ecommerce
            - --balance-similar-node-groups
            - --skip-nodes-with-system-pods=false
          env:
            - name: AWS_REGION
              value: us-west-2
```

## Hands-On Exercises

### Exercise 11.1: Implement Caching

1. Set up Redis caching for product data
2. Implement cache invalidation strategies
3. Add query result caching
4. Monitor cache hit rates

### Exercise 11.2: Database Optimization

1. Analyze slow queries
2. Add appropriate indexes
3. Implement query optimization
4. Set up connection pooling

### Exercise 11.3: Frontend Performance

1. Implement lazy loading for images
2. Add virtual scrolling for product lists
3. Optimize bundle size
4. Implement service worker for caching

### Exercise 11.4: Load Testing

1. Set up load testing with Locust
2. Test API endpoints under load
3. Identify performance bottlenecks
4. Optimize based on results

### Exercise 11.5: Auto-scaling

1. Configure horizontal pod autoscaling
2. Set up cluster autoscaling
3. Test scaling under load
4. Monitor scaling metrics

## Key Performance Metrics

### Response Time Metrics

- Average response time: < 200ms
- 95th percentile: < 500ms
- 99th percentile: < 1000ms

### Throughput Metrics

- Requests per second: > 1000 RPS
- Concurrent users: > 10,000
- Database queries per second: < 500 QPS

### Resource Utilization

- CPU utilization: < 70%
- Memory utilization: < 80%
- Database connections: < 80% of pool

## Best Practices

### Caching Strategy

- Cache frequently accessed data
- Implement cache warming
- Use appropriate TTL values
- Monitor cache hit rates

### Database Optimization

- Use appropriate indexes
- Optimize query patterns
- Implement connection pooling
- Monitor slow queries

### Frontend Performance

- Lazy load non-critical resources
- Optimize images and assets
- Implement code splitting
- Use CDN for static assets

## Next Steps

After completing this module, proceed to [Module 12: Advanced Features and Architecture](../12-advanced-features-and-architecture) to learn about implementing advanced features like real-time functionality, microservices architecture, and internationalization.
