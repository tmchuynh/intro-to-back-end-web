import BackToTop from "@/components/BackToTop";

# Design Patterns

## Table of Contents

## Introduction to Design Patterns

Design patterns are reusable solutions to common software design problems. They provide a proven approach to solving specific design challenges and can be applied across different programming languages and paradigms. Design patterns help in creating flexible and maintainable code by promoting best practices and established design principles.
For example, the Singleton pattern ensures that a class has only one instance and provides a global point of access to it. This is useful in scenarios where you need to manage shared resources, such as a configuration manager or a logging service. By using the Singleton pattern, you can ensure that there is only one instance of the class throughout the application, preventing conflicts and ensuring consistent behavior.
Other common design patterns include the Factory pattern for creating objects, the Observer pattern for implementing event-driven systems, and the Decorator pattern for adding functionality to existing objects without modifying their structure. By leveraging design patterns, developers can create software that is easier to understand, maintain, and extend.

## Key Design Patterns

### Singleton Pattern

The Singleton pattern ensures that a class has only one instance and provides a global point of access to it. This is useful in scenarios where you need to manage shared resources, such as a configuration manager or a logging service. By using the Singleton pattern, you can ensure that there is only one instance of the class throughout the application, preventing conflicts and ensuring consistent behavior.
This pattern is implemented by making the class constructor private, providing a static method to access the instance, and using a static variable to hold the instance. When the static method is called, it checks if the instance already exists; if not, it creates a new instance and returns it.

```sql title="Singleton Pattern Example in SQL"
CREATE TABLE SingletonExample (
    id INT PRIMARY KEY,
    value VARCHAR(255)
);
CREATE OR REPLACE FUNCTION get_singleton_instance()
RETURNS SETOF SingletonExample AS $$
DECLARE
    instance SingletonExample;
BEGIN
    SELECT * INTO instance FROM SingletonExample WHERE id = 1;
    IF NOT FOUND THEN
        INSERT INTO SingletonExample (id, value) VALUES (1, 'Initial Value');
        SELECT * INTO instance FROM SingletonExample WHERE id = 1;
    END IF;
    RETURN NEXT instance;
END;
$$ LANGUAGE plpgsql;
```

### Factory Pattern

The Factory pattern provides a way to create objects without specifying the exact class of the object that will be created. It defines an interface for creating objects, but allows subclasses to alter the type of objects that will be created. This pattern is useful when you want to encapsulate the instantiation logic and provide a flexible way to create objects based on specific conditions or configurations.

```sql title="Factory Pattern Example in SQL"
CREATE OR REPLACE FUNCTION create_shape(shape_type VARCHAR)
RETURNS SETOF Shape AS $$
DECLARE
    new_shape Shape;
BEGIN
    IF shape_type = 'Circle' THEN
        INSERT INTO Shape (type, radius) VALUES ('Circle', 5) RETURNING * INTO new_shape;
    ELSIF shape_type = 'Square' THEN
        INSERT INTO Shape (type, side_length) VALUES ('Square', 4) RETURNING * INTO new_shape;
    ELSE
        RAISE EXCEPTION 'Unknown shape type: %', shape_type;
    END IF;
    RETURN NEXT new_shape;
END;
$$ LANGUAGE plpgsql;
```

### Observer Pattern

The Observer pattern defines a one-to-many dependency between objects, allowing one object (the subject) to notify multiple dependent objects (observers) about changes in its state. This pattern is commonly used in event-driven systems, where you want to decouple the components that produce events from those that consume them. Observers can subscribe to the subject and receive updates whenever the subject's state changes, enabling a flexible and extensible architecture.

```sql title="Observer Pattern Example in SQL"
CREATE TABLE Subject (
    id INT PRIMARY KEY,
    state VARCHAR(255)
);
CREATE TABLE Observer (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    subject_id INT REFERENCES Subject(id)
);
CREATE OR REPLACE FUNCTION notify_observers(subject_id INT)
RETURNS VOID AS $$
DECLARE
    observer Observer%ROWTYPE;
BEGIN
    FOR observer IN SELECT * FROM Observer WHERE subject_id = subject_id LOOP
        RAISE NOTICE 'Notifying observer %: Subject state changed to %', observer.name, (SELECT state FROM Subject WHERE id = subject_id);
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### Builder Pattern

The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations. This pattern is useful when you want to create an object step by step, especially when the object has many optional parameters or configurations. By using a builder, you can create a fluent interface that makes it easy to construct objects with varying configurations without cluttering the constructor with numerous parameters.

```sql title="Builder Pattern Example in SQL"
CREATE TYPE ComplexObject AS (
    part1 VARCHAR(255),
    part2 VARCHAR(255),
    part3 VARCHAR(255)
);
CREATE OR REPLACE FUNCTION build_complex_object(part1 VARCHAR, part2 VARCHAR, part3 VARCHAR)
RETURNS ComplexObject AS $$
BEGIN
    RETURN ROW(part1, part2, part3)::ComplexObject;
END;
$$ LANGUAGE plpgsql;
```

### Prototype Pattern

The Prototype pattern allows you to create new objects by copying an existing object, known as the prototype. This pattern is useful when the cost of creating a new instance of an object is more expensive than copying an existing one. By using prototypes, you can create new objects without needing to know their concrete classes, promoting flexibility and reducing dependencies.

```sql title="Prototype Pattern Example in SQL"
CREATE TYPE Prototype AS (
    id INT,
    name VARCHAR(255)
);
CREATE OR REPLACE FUNCTION clone_prototype(original Prototype)
RETURNS Prototype AS $$
BEGIN
    RETURN ROW(original.id, original.name)::Prototype;
END;
$$ LANGUAGE plpgsql;
```

### Composite Pattern

The Composite pattern allows you to compose objects into tree structures to represent part-whole hierarchies. This pattern is useful when you want to treat individual objects and compositions of objects uniformly. By using the Composite pattern, you can create complex structures where clients can interact with both individual objects and groups of objects in a consistent manner.

```sql title="Composite Pattern Example in SQL"
CREATE TABLE Component (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    parent_id INT REFERENCES Component(id)
);
CREATE OR REPLACE FUNCTION add_component(name VARCHAR, parent_id INT)
RETURNS VOID AS $$
BEGIN
    INSERT INTO Component (name, parent_id) VALUES (name, parent_id);
END;
$$ LANGUAGE plpgsql;
```

### Facade Pattern

The Facade pattern provides a simplified interface to a complex subsystem, making it easier to use. This pattern is useful when you want to hide the complexities of a system and provide a more straightforward interface for clients. By using a facade, you can encapsulate the interactions with multiple subsystems and expose only the necessary methods, promoting ease of use and reducing dependencies.

```sql title="Facade Pattern Example in SQL"
CREATE TABLE SubsystemA (
    id INT PRIMARY KEY,
    data VARCHAR(255)
);
CREATE TABLE SubsystemB (
    id INT PRIMARY KEY,
    info VARCHAR(255)
);
CREATE OR REPLACE FUNCTION facade_method(data VARCHAR, info VARCHAR)
RETURNS VOID AS $$
BEGIN
    INSERT INTO SubsystemA (data) VALUES (data);
    INSERT INTO SubsystemB (info) VALUES (info);
END;
$$ LANGUAGE plpgsql;
```

### Decorator Pattern

The Decorator pattern allows you to add new functionality to existing objects without modifying their structure. It involves creating a set of decorator classes that are used to wrap concrete components. This pattern is useful when you want to enhance the behavior of an object dynamically, without altering its original code. By using decorators, you can create a flexible and reusable design that allows for easy extension and modification of object behavior.

```sql title="Decorator Pattern Example in SQL"
CREATE TABLE Component (
    id INT PRIMARY KEY,
    name VARCHAR(255)
);
CREATE TABLE Decorator (
    id INT PRIMARY KEY,
    component_id INT REFERENCES Component(id),
    additional_behavior VARCHAR(255)
);
CREATE OR REPLACE FUNCTION add_decorator(component_id INT, behavior VARCHAR)
RETURNS VOID AS $$
BEGIN
    INSERT INTO Decorator (component_id, additional_behavior) VALUES (component_id, behavior);
END;
$$ LANGUAGE plpgsql;
```

### Template Method Pattern

The Template Method pattern defines the skeleton of an algorithm in a base class, allowing subclasses to override specific steps without changing the overall structure. This pattern is useful when you have a common algorithm that can be customized by subclasses. By using the Template Method pattern, you can promote code reuse and maintainability while allowing for flexibility in the implementation of specific steps.

```sql title="Template Method Pattern Example in SQL"
CREATE OR REPLACE FUNCTION template_method(param1 VARCHAR, param2 VARCHAR)
RETURNS VOID AS $$
BEGIN
    -- Step 1: Common logic
    RAISE NOTICE 'Executing common logic with parameters: %, %', param1, param2;
    -- Step 2: Call subclass-specific logic
    PERFORM subclass_specific_logic(param1, param2);
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION subclass_specific_logic(param1 VARCHAR, param2 VARCHAR)
RETURNS VOID AS $$
BEGIN
    -- Subclass-specific logic implementation
    RAISE NOTICE 'Executing subclass-specific logic with parameters: %, %', param1, param2;
END;
$$ LANGUAGE plpgsql;
```

### Strategy Pattern

The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern allows you to select an algorithm at runtime, promoting flexibility and enabling the client to choose the appropriate algorithm based on specific conditions or requirements. The Strategy pattern is useful when you have multiple algorithms that can be applied to a problem, and you want to decouple the algorithm selection from the client code.

```sql title="Strategy Pattern Example in SQL"
CREATE OR REPLACE FUNCTION execute_strategy(strategy_name VARCHAR, param1 VARCHAR, param2 VARCHAR)
RETURNS VOID AS $$
BEGIN
    IF strategy_name = 'StrategyA' THEN
        PERFORM strategy_a(param1, param2);
    ELSIF strategy_name = 'StrategyB' THEN
        PERFORM strategy_b(param1, param2);
    ELSE
        RAISE EXCEPTION 'Unknown strategy: %', strategy_name;
    END IF;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION strategy_a(param1 VARCHAR, param2 VARCHAR)
RETURNS VOID AS $$
BEGIN
    -- Implementation of Strategy A
    RAISE NOTICE 'Executing Strategy A with parameters: %, %', param1, param2;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION strategy_b(param1 VARCHAR, param2 VARCHAR)
RETURNS VOID AS $$
BEGIN
    -- Implementation of Strategy B
    RAISE NOTICE 'Executing Strategy B with parameters: %, %', param1, param2;
END;
$$ LANGUAGE plpgsql;
```

### Chain of Responsibility Pattern

The Chain of Responsibility pattern allows multiple objects to handle a request without the sender needing to know which object will handle it. This pattern promotes loose coupling by allowing the request to pass through a chain of handlers until one of them processes it. It is useful when you want to decouple the sender and receiver of a request, enabling more flexible and extensible designs.

```sql title="Chain of Responsibility Pattern Example in SQL"
CREATE TABLE Handler (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    next_handler_id INT REFERENCES Handler(id)
);
CREATE OR REPLACE FUNCTION handle_request(handler_id INT, request VARCHAR)
RETURNS VOID AS $$
DECLARE
    current_handler Handler%ROWTYPE;
BEGIN
    SELECT * INTO current_handler FROM Handler WHERE id = handler_id;
    IF current_handler IS NULL THEN
        RAISE EXCEPTION 'Handler not found: %', handler_id;
    END IF;
    RAISE NOTICE 'Handler % processing request: %', current_handler.name, request;
    IF current_handler.next_handler_id IS NOT NULL THEN
        PERFORM handle_request(current_handler.next_handler_id, request);
    ELSE
        RAISE NOTICE 'End of chain reached. Request processed by %', current_handler.name;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

### State Pattern

The State pattern allows an object to alter its behavior when its internal state changes. This pattern is useful when an object needs to exhibit different behaviors based on its current state, such as a traffic light that changes its color based on time or conditions. By using the State pattern, you can encapsulate state-specific behavior in separate classes, promoting cleaner and more maintainable code.

```sql title="State Pattern Example in SQL"
CREATE TABLE State (
    id INT PRIMARY KEY,
    name VARCHAR(255)
);
CREATE TABLE Context (
    id INT PRIMARY KEY,
    current_state_id INT REFERENCES State(id)
);
CREATE OR REPLACE FUNCTION change_state(context_id INT, new_state_id INT)
RETURNS VOID AS $$
BEGIN
    UPDATE Context SET current_state_id = new_state_id WHERE id = context_id;
    RAISE NOTICE 'Context % changed to state %', context_id, new_state_id;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION perform_action(context_id INT)
RETURNS VOID AS $$
DECLARE
    current_state State%ROWTYPE;
BEGIN
    SELECT * INTO current_state FROM Context JOIN State ON Context.current_state_id = State.id WHERE Context.id = context_id;
    IF current_state IS NULL THEN
        RAISE EXCEPTION 'Context not found or has no state: %', context_id;
    END IF;
    RAISE NOTICE 'Performing action in state %', current_state.name;
    -- Add state-specific behavior here
END;
$$ LANGUAGE plpgsql;
```

### Command Pattern

The Command pattern encapsulates a request as an object, allowing you to parameterize clients with queues, requests, and operations. This pattern is useful for implementing undo/redo functionality, logging operations, or queuing requests for execution. By using the Command pattern, you can decouple the sender of a request from the receiver, enabling more flexible and extensible designs.

```sql title="Command Pattern Example in SQL"
CREATE TABLE Command (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    executed BOOLEAN DEFAULT FALSE
);
CREATE OR REPLACE FUNCTION execute_command(command_id INT)
RETURNS VOID AS $$
BEGIN
    UPDATE Command SET executed = TRUE WHERE id = command_id;
    RAISE NOTICE 'Command % executed', command_id;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION undo_command(command_id INT)
RETURNS VOID AS $$
BEGIN
    UPDATE Command SET executed = FALSE WHERE id = command_id;
    RAISE NOTICE 'Command % undone', command_id;
END;
$$ LANGUAGE plpgsql;
```

### Memento Pattern

The Memento pattern allows you to capture and restore an object's internal state without exposing its implementation details. This pattern is useful when you want to implement undo/redo functionality or save the state of an object at a specific point in time. By using the Memento pattern, you can create a snapshot of an object's state and restore it later, promoting encapsulation and separation of concerns.

```sql title="Memento Pattern Example in SQL"
CREATE TABLE Memento (
    id INT PRIMARY KEY,
    state VARCHAR(255)
);
CREATE TABLE Originator (
    id INT PRIMARY KEY,
    current_state VARCHAR(255)
);
CREATE OR REPLACE FUNCTION create_memento(originator_id INT)
RETURNS INT AS $$
DECLARE
    new_memento_id INT;
BEGIN
    INSERT INTO Memento (state) SELECT current_state FROM Originator WHERE id = originator_id RETURNING id INTO new_memento_id;
    RAISE NOTICE 'Memento created with ID % for originator %', new_memento_id, originator_id;
    RETURN new_memento_id;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION restore_memento(originator_id INT, memento_id INT)
RETURNS VOID AS $$
BEGIN
    UPDATE Originator SET current_state = (SELECT state FROM Memento WHERE id = memento_id) WHERE id = originator_id;
    RAISE NOTICE 'Originator % restored to memento %', originator_id, memento_id;
END;
$$ LANGUAGE plpgsql;
```

### Adapter Pattern

The Adapter pattern allows incompatible interfaces to work together by converting the interface of one class into another that the client expects. This pattern is useful when you want to integrate existing classes with a new interface without modifying their code. By using an adapter, you can create a bridge between the incompatible interfaces, enabling them to collaborate seamlessly.

```sql title="Adapter Pattern Example in SQL"
CREATE TABLE Target (
    id INT PRIMARY KEY,
    name VARCHAR(255)
);
CREATE TABLE Adaptee (
    id INT PRIMARY KEY,
    description VARCHAR(255)
);
CREATE OR REPLACE FUNCTION adapt_adaptee(adaptee_id INT)
RETURNS Target AS $$
DECLARE
    adapted_target Target%ROWTYPE;
BEGIN
    SELECT id, description INTO adapted_target FROM Adaptee WHERE id = adaptee_id;
    IF adapted_target IS NULL THEN
        RAISE EXCEPTION 'Adaptee not found: %', adaptee_id;
    END IF;
    adapted_target.name := adapted_target.description; -- Adapting the interface
    RAISE NOTICE 'Adaptee % adapted to Target with name %', adaptee_id, adapted_target.name;
    RETURN adapted_target;
END;
$$ LANGUAGE plpgsql;
```

### Bridge Pattern

The Bridge pattern separates an interface from its implementation, allowing them to vary independently. This pattern is useful when you want to decouple abstraction from implementation, enabling you to change either without affecting the other. By using the Bridge pattern, you can create a flexible architecture that allows for easy extension and modification of both the interface and its implementation.

```sql title="Bridge Pattern Example in SQL"
CREATE TABLE Abstraction (
    id INT PRIMARY KEY,
    name VARCHAR(255)
);
CREATE TABLE Implementation (
    id INT PRIMARY KEY,
    details VARCHAR(255)
);
CREATE OR REPLACE FUNCTION create_bridge(abstraction_name VARCHAR, implementation_details VARCHAR)
RETURNS VOID AS $$
BEGIN
    INSERT INTO Abstraction (name) VALUES (abstraction_name);
    INSERT INTO Implementation (details) VALUES (implementation_details);
    RAISE NOTICE 'Bridge created with Abstraction % and Implementation %', abstraction_name, implementation_details;
END;
$$ LANGUAGE plpgsql;
```

### Flyweight Pattern

The Flyweight pattern is used to minimize memory usage by sharing common data among multiple objects. This pattern is useful when you have a large number of similar objects that share some state, allowing you to reduce memory overhead by storing shared data in a single location. By using the Flyweight pattern, you can create lightweight objects that can be reused, promoting efficiency and performance.

```sql title="Flyweight Pattern Example in SQL"
CREATE TABLE Flyweight (
    id INT PRIMARY KEY,
    shared_data VARCHAR(255)
);
CREATE TABLE Context (
    id INT PRIMARY KEY,
    flyweight_id INT REFERENCES Flyweight(id),
    unique_data VARCHAR(255)
);
CREATE OR REPLACE FUNCTION create_flyweight(shared_data VARCHAR, unique_data VARCHAR)
RETURNS VOID AS $$
BEGIN
    INSERT INTO Flyweight (shared_data) VALUES (shared_data);
    INSERT INTO Context (flyweight_id, unique_data) VALUES (currval('Flyweight_id_seq'), unique_data);
    RAISE NOTICE 'Flyweight created with shared data % and unique data %', shared_data, unique_data;
END;
$$ LANGUAGE plpgsql;
```

### Interpreter Pattern

The Interpreter pattern defines a representation for a language's grammar along with an interpreter that uses this representation to interpret sentences in the language. This pattern is useful when you want to evaluate expressions or parse input based on a defined grammar. By using the Interpreter pattern, you can create a flexible and extensible system for interpreting complex expressions or commands.

```sql title="Interpreter Pattern Example in SQL"
CREATE TABLE Expression (
    id INT PRIMARY KEY,
    expression VARCHAR(255)
);
CREATE OR REPLACE FUNCTION interpret_expression(expression_id INT)
RETURNS VOID AS $$
DECLARE
    expr Expression%ROWTYPE;
BEGIN
    SELECT * INTO expr FROM Expression WHERE id = expression_id;
    IF expr IS NULL THEN
        RAISE EXCEPTION 'Expression not found: %', expression_id;
    END IF;
    RAISE NOTICE 'Interpreting expression: %', expr.expression;
    -- Add logic to interpret the expression here
END;
$$ LANGUAGE plpgsql;
```

### Visitor Pattern

The Visitor pattern allows you to define new operations on a set of objects without changing their classes. This pattern is useful when you want to perform operations on a collection of objects with different types, enabling you to add new functionality without modifying the existing code. By using the Visitor pattern, you can create a flexible and extensible design that allows for easy addition of new operations.

```sql title="Visitor Pattern Example in SQL"
CREATE TABLE Element (
    id INT PRIMARY KEY,
    name VARCHAR(255)
);
CREATE TABLE Visitor (
    id INT PRIMARY KEY,
    operation VARCHAR(255)
);
CREATE OR REPLACE FUNCTION visit_element(element_id INT, visitor_id INT)
RETURNS VOID AS $$
DECLARE
    element Element%ROWTYPE;
    visitor Visitor%ROWTYPE;
BEGIN
    SELECT * INTO element FROM Element WHERE id = element_id;
    IF element IS NULL THEN
        RAISE EXCEPTION 'Element not found: %', element_id;
    END IF;
    SELECT * INTO visitor FROM Visitor WHERE id = visitor_id;
    IF visitor IS NULL THEN
        RAISE EXCEPTION 'Visitor not found: %', visitor_id;
    END IF;
    RAISE NOTICE 'Visiting element % with visitor %: %', element.name, visitor.operation, visitor.operation;
    -- Add logic to perform the visitor operation on the element here
END;
$$ LANGUAGE plpgsql;
```

### Proxy Pattern

The Proxy pattern provides a surrogate or placeholder for another object to control access to it. This pattern is useful when you want to add an additional layer of control or functionality to an existing object, such as lazy loading, access control, or logging. By using a proxy, you can intercept requests to the real object and provide additional behavior without modifying the original object's code.

```sql title="Proxy Pattern Example in SQL"
CREATE TABLE RealObject (
    id INT PRIMARY KEY,
    name VARCHAR(255)
);
CREATE TABLE ProxyObject (
    id INT PRIMARY KEY,
    real_object_id INT REFERENCES RealObject(id),
    access_control BOOLEAN DEFAULT TRUE
);
CREATE OR REPLACE FUNCTION access_real_object(proxy_id INT)
RETURNS VOID AS $$
DECLARE
    proxy ProxyObject%ROWTYPE;
BEGIN
    SELECT * INTO proxy FROM ProxyObject WHERE id = proxy_id;
    IF proxy IS NULL THEN
        RAISE EXCEPTION 'Proxy not found: %', proxy_id;
    END IF;
    IF NOT proxy.access_control THEN
        RAISE EXCEPTION 'Access denied to real object through proxy %', proxy_id;
    END IF;
    RAISE NOTICE 'Accessing real object % through proxy %', proxy.real_object_id, proxy_id;
    -- Add logic to access the real object here
END;
$$ LANGUAGE plpgsql;
```

<BackToTop />
