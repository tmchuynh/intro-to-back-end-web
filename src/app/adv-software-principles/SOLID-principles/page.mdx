import BackToTop from "@/components/BackToTop";

# SOLID Principles

## Table of Contents

## Introduction to SOLID Principles

SOLID is an acronym that represents five key principles of object-oriented programming and design. These principles aim to make software designs more understandable, flexible, and maintainable. By adhering to SOLID principles, developers can create systems that are easier to manage and extend over time.

The SOLID principles were introduced by Robert C. Martin (Uncle Bob) and have become fundamental guidelines for writing clean, maintainable object-oriented code. These principles help developers:

- Reduce code coupling
- Increase code cohesion
- Make code more testable
- Improve code reusability
- Facilitate easier maintenance and refactoring

## The Five SOLID Principles

### Single Responsibility Principle (SRP)

**Definition**: A class should have only one reason to change, meaning it should have only one job or responsibility.

The Single Responsibility Principle helps to reduce the complexity of classes and makes them easier to understand and maintain. When a class has multiple responsibilities, it becomes harder to modify or extend without affecting other parts of the system.

#### SRP Violation Example

```typescript
// ❌ Violates SRP - Multiple responsibilities
class User {
    private name: string;
    private email: string;
    
    constructor(name: string, email: string) {
        this.name = name;
        this.email = email;
    }
    
    // Responsibility 1: User data management
    getName(): string {
        return this.name;
    }
    
    getEmail(): string {
        return this.email;
    }
    
    // Responsibility 2: Email validation
    validateEmail(): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(this.email);
    }
    
    // Responsibility 3: Database operations
    save(): void {
        // Database save logic
        console.log(`Saving user ${this.name} to database`);
    }
    
    // Responsibility 4: Email sending
    sendWelcomeEmail(): void {
        // Email sending logic
        console.log(`Sending welcome email to ${this.email}`);
    }
}
```

#### SRP Compliant Solution

```typescript
// ✅ Follows SRP - Single responsibility per class
class User {
    private name: string;
    private email: string;
    
    constructor(name: string, email: string) {
        this.name = name;
        this.email = email;
    }
    
    getName(): string {
        return this.name;
    }
    
    getEmail(): string {
        return this.email;
    }
}

class EmailValidator {
    static validate(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
}

class UserRepository {
    save(user: User): void {
        console.log(`Saving user ${user.getName()} to database`);
    }
    
    findById(id: number): User | null {
        // Database retrieval logic
        return null;
    }
}

class EmailService {
    sendWelcomeEmail(user: User): void {
        console.log(`Sending welcome email to ${user.getEmail()}`);
    }
}
```

#### Benefits of SRP

- **Easier Testing**: Each class has a focused responsibility
- **Better Maintainability**: Changes to one responsibility don't affect others
- **Improved Reusability**: Classes can be reused in different contexts
- **Clearer Code**: Purpose of each class is immediately apparent

### Open/Closed Principle (OCP)

**Definition**: Software entities should be open for extension but closed for modification.

This means you should be able to add new functionality without changing existing code. This principle encourages the use of interfaces and abstract classes.

#### OCP Violation Example

```typescript
// ❌ Violates OCP - Must modify existing code to add new shapes
class AreaCalculator {
    calculateArea(shape: any): number {
        if (shape.type === 'rectangle') {
            return shape.width * shape.height;
        } else if (shape.type === 'circle') {
            return Math.PI * shape.radius * shape.radius;
        }
        // Adding a new shape requires modifying this method
        return 0;
    }
}
```

#### OCP Compliant Solution

```typescript
// ✅ Follows OCP - Can extend without modifying existing code
interface Shape {
    calculateArea(): number;
}

class Rectangle implements Shape {
    constructor(private width: number, private height: number) {}
    
    calculateArea(): number {
        return this.width * this.height;
    }
}

class Circle implements Shape {
    constructor(private radius: number) {}
    
    calculateArea(): number {
        return Math.PI * this.radius * this.radius;
    }
}

// New shape can be added without modifying existing code
class Triangle implements Shape {
    constructor(private base: number, private height: number) {}
    
    calculateArea(): number {
        return 0.5 * this.base * this.height;
    }
}

class AreaCalculator {
    calculateArea(shape: Shape): number {
        return shape.calculateArea();
    }
    
    calculateTotalArea(shapes: Shape[]): number {
        return shapes.reduce((total, shape) => total + shape.calculateArea(), 0);
    }
}
```

#### Advanced OCP Example with Strategy Pattern

```typescript
// Payment processing system following OCP
interface PaymentStrategy {
    processPayment(amount: number): boolean;
}

class CreditCardPayment implements PaymentStrategy {
    constructor(private cardNumber: string, private cvv: string) {}
    
    processPayment(amount: number): boolean {
        console.log(`Processing $${amount} via Credit Card ending in ${this.cardNumber.slice(-4)}`);
        return true;
    }
}

class PayPalPayment implements PaymentStrategy {
    constructor(private email: string) {}
    
    processPayment(amount: number): boolean {
        console.log(`Processing $${amount} via PayPal for ${this.email}`);
        return true;
    }
}

// New payment method can be added without modifying existing code
class CryptocurrencyPayment implements PaymentStrategy {
    constructor(private walletAddress: string) {}
    
    processPayment(amount: number): boolean {
        console.log(`Processing $${amount} via Cryptocurrency to ${this.walletAddress}`);
        return true;
    }
}

class PaymentProcessor {
    processPayment(amount: number, strategy: PaymentStrategy): boolean {
        return strategy.processPayment(amount);
    }
}
```

### Liskov Substitution Principle (LSP)

**Definition**: Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.

Subclasses should be substitutable for their base classes without altering the desirable properties of the program.

#### LSP Violation Example

```typescript
// ❌ Violates LSP - Penguin cannot fly
class Bird {
    fly(): void {
        console.log("Bird is flying");
    }
}

class Sparrow extends Bird {
    fly(): void {
        console.log("Sparrow is flying");
    }
}

class Penguin extends Bird {
    fly(): void {
        throw new Error("Penguins cannot fly!"); // Breaks LSP
    }
}

// This code will fail when a Penguin is substituted for a Bird
function makeBirdFly(bird: Bird): void {
    bird.fly(); // Will throw error for Penguin
}
```

#### LSP Compliant Solution

```typescript
// ✅ Follows LSP - Proper inheritance hierarchy
abstract class Bird {
    abstract makeSound(): void;
    
    eat(): void {
        console.log("Bird is eating");
    }
}

interface Flyable {
    fly(): void;
}

interface Swimmable {
    swim(): void;
}

class Sparrow extends Bird implements Flyable {
    makeSound(): void {
        console.log("Chirp chirp");
    }
    
    fly(): void {
        console.log("Sparrow is flying");
    }
}

class Penguin extends Bird implements Swimmable {
    makeSound(): void {
        console.log("Squawk squawk");
    }
    
    swim(): void {
        console.log("Penguin is swimming");
    }
}

class Eagle extends Bird implements Flyable {
    makeSound(): void {
        console.log("Screech");
    }
    
    fly(): void {
        console.log("Eagle is soaring");
    }
}

// Functions work correctly with any Bird subclass
function feedBird(bird: Bird): void {
    bird.eat(); // Works for all birds
    bird.makeSound(); // Works for all birds
}

function makeFlyableFly(flyable: Flyable): void {
    flyable.fly(); // Only works with birds that can fly
}
```

#### Rectangle-Square LSP Example

```typescript
// ❌ Classic LSP violation
class Rectangle {
    constructor(protected width: number, protected height: number) {}
    
    setWidth(width: number): void {
        this.width = width;
    }
    
    setHeight(height: number): void {
        this.height = height;
    }
    
    getArea(): number {
        return this.width * this.height;
    }
}

class Square extends Rectangle {
    constructor(side: number) {
        super(side, side);
    }
    
    setWidth(width: number): void {
        this.width = width;
        this.height = width; // Violates LSP - unexpected behavior
    }
    
    setHeight(height: number): void {
        this.width = height;
        this.height = height; // Violates LSP - unexpected behavior
    }
}

// ✅ LSP compliant solution
interface Shape {
    getArea(): number;
}

class Rectangle implements Shape {
    constructor(private width: number, private height: number) {}
    
    setWidth(width: number): void {
        this.width = width;
    }
    
    setHeight(height: number): void {
        this.height = height;
    }
    
    getArea(): number {
        return this.width * this.height;
    }
}

class Square implements Shape {
    constructor(private side: number) {}
    
    setSide(side: number): void {
        this.side = side;
    }
    
    getArea(): number {
        return this.side * this.side;
    }
}
```

### Interface Segregation Principle (ISP)

**Definition**: No client should be forced to depend on methods it does not use.

This principle encourages the creation of small, specific interfaces rather than large, general-purpose ones.

#### ISP Violation Example

```typescript
// ❌ Violates ISP - Large interface with unused methods
interface Vehicle {
    drive(): void;
    fly(): void;
    sail(): void;
    startEngine(): void;
    stopEngine(): void;
}

class Car implements Vehicle {
    drive(): void {
        console.log("Car is driving");
    }
    
    startEngine(): void {
        console.log("Car engine started");
    }
    
    stopEngine(): void {
        console.log("Car engine stopped");
    }
    
    // Forced to implement unused methods
    fly(): void {
        throw new Error("Cars cannot fly");
    }
    
    sail(): void {
        throw new Error("Cars cannot sail");
    }
}
```

#### ISP Compliant Solution

```typescript
// ✅ Follows ISP - Small, specific interfaces
interface Drivable {
    drive(): void;
}

interface Flyable {
    fly(): void;
}

interface Sailable {
    sail(): void;
}

interface Engine {
    startEngine(): void;
    stopEngine(): void;
}

class Car implements Drivable, Engine {
    drive(): void {
        console.log("Car is driving");
    }
    
    startEngine(): void {
        console.log("Car engine started");
    }
    
    stopEngine(): void {
        console.log("Car engine stopped");
    }
}

class Airplane implements Flyable, Engine {
    fly(): void {
        console.log("Airplane is flying");
    }
    
    startEngine(): void {
        console.log("Airplane engines started");
    }
    
    stopEngine(): void {
        console.log("Airplane engines stopped");
    }
}

class Sailboat implements Sailable {
    sail(): void {
        console.log("Sailboat is sailing");
    }
}

class Amphibian implements Drivable, Sailable, Engine {
    drive(): void {
        console.log("Amphibian is driving on land");
    }
    
    sail(): void {
        console.log("Amphibian is sailing on water");
    }
    
    startEngine(): void {
        console.log("Amphibian engine started");
    }
    
    stopEngine(): void {
        console.log("Amphibian engine stopped");
    }
}
```

#### Advanced ISP Example with Worker Interfaces

```typescript
// ❌ Fat interface forcing unnecessary dependencies
interface Worker {
    work(): void;
    eat(): void;
    sleep(): void;
    code(): void;
    design(): void;
    manage(): void;
}

// ✅ Segregated interfaces
interface Workable {
    work(): void;
}

interface Feedable {
    eat(): void;
}

interface Sleepable {
    sleep(): void;
}

interface Programmable {
    code(): void;
}

interface Designable {
    design(): void;
}

interface Manageable {
    manage(): void;
}

class Developer implements Workable, Feedable, Sleepable, Programmable {
    work(): void {
        console.log("Developer is working");
    }
    
    eat(): void {
        console.log("Developer is eating");
    }
    
    sleep(): void {
        console.log("Developer is sleeping");
    }
    
    code(): void {
        console.log("Developer is coding");
    }
}

class Designer implements Workable, Feedable, Sleepable, Designable {
    work(): void {
        console.log("Designer is working");
    }
    
    eat(): void {
        console.log("Designer is eating");
    }
    
    sleep(): void {
        console.log("Designer is sleeping");
    }
    
    design(): void {
        console.log("Designer is designing");
    }
}

class ProjectManager implements Workable, Feedable, Sleepable, Manageable {
    work(): void {
        console.log("Project Manager is working");
    }
    
    eat(): void {
        console.log("Project Manager is eating");
    }
    
    sleep(): void {
        console.log("Project Manager is sleeping");
    }
    
    manage(): void {
        console.log("Project Manager is managing");
    }
}
```

### Dependency Inversion Principle (DIP)

**Definition**: High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details; details should depend on abstractions.

This principle encourages the use of interfaces or abstract classes to decouple high-level and low-level components.

#### DIP Violation Example

```typescript
// ❌ Violates DIP - High-level module depends on low-level modules
class MySQLDatabase {
    save(data: string): void {
        console.log(`Saving data to MySQL: ${data}`);
    }
}

class EmailService {
    send(message: string): void {
        console.log(`Sending email: ${message}`);
    }
}

class OrderProcessor {
    private database: MySQLDatabase;
    private emailService: EmailService;
    
    constructor() {
        this.database = new MySQLDatabase(); // Tight coupling
        this.emailService = new EmailService(); // Tight coupling
    }
    
    processOrder(orderData: string): void {
        // Process order logic
        this.database.save(orderData);
        this.emailService.send("Order processed successfully");
    }
}
```

#### DIP Compliant Solution

```typescript
// ✅ Follows DIP - Depends on abstractions
interface Database {
    save(data: string): void;
}

interface NotificationService {
    send(message: string): void;
}

class MySQLDatabase implements Database {
    save(data: string): void {
        console.log(`Saving data to MySQL: ${data}`);
    }
}

class PostgreSQLDatabase implements Database {
    save(data: string): void {
        console.log(`Saving data to PostgreSQL: ${data}`);
    }
}

class EmailService implements NotificationService {
    send(message: string): void {
        console.log(`Sending email: ${message}`);
    }
}

class SMSService implements NotificationService {
    send(message: string): void {
        console.log(`Sending SMS: ${message}`);
    }
}

class OrderProcessor {
    constructor(
        private database: Database,
        private notificationService: NotificationService
    ) {}
    
    processOrder(orderData: string): void {
        // Process order logic
        this.database.save(orderData);
        this.notificationService.send("Order processed successfully");
    }
}

// Usage with dependency injection
const mySQLDb = new MySQLDatabase();
const emailService = new EmailService();
const orderProcessor = new OrderProcessor(mySQLDb, emailService);

// Easy to swap implementations
const postgreSQLDb = new PostgreSQLDatabase();
const smsService = new SMSService();
const anotherOrderProcessor = new OrderProcessor(postgreSQLDb, smsService);
```

#### Advanced DIP Example with Repository Pattern

```typescript
// Domain entity
class User {
    constructor(
        public id: number,
        public name: string,
        public email: string
    ) {}
}

// Abstract repository interface
interface UserRepository {
    findById(id: number): Promise<User | null>;
    save(user: User): Promise<void>;
    delete(id: number): Promise<void>;
}

// Concrete implementations
class DatabaseUserRepository implements UserRepository {
    async findById(id: number): Promise<User | null> {
        console.log(`Finding user ${id} in database`);
        // Database logic here
        return new User(id, "John Doe", "john@example.com");
    }
    
    async save(user: User): Promise<void> {
        console.log(`Saving user ${user.name} to database`);
        // Database save logic
    }
    
    async delete(id: number): Promise<void> {
        console.log(`Deleting user ${id} from database`);
        // Database delete logic
    }
}

class InMemoryUserRepository implements UserRepository {
    private users: Map<number, User> = new Map();
    
    async findById(id: number): Promise<User | null> {
        return this.users.get(id) || null;
    }
    
    async save(user: User): Promise<void> {
        this.users.set(user.id, user);
    }
    
    async delete(id: number): Promise<void> {
        this.users.delete(id);
    }
}

// High-level service depends on abstraction
class UserService {
    constructor(private userRepository: UserRepository) {}
    
    async getUser(id: number): Promise<User | null> {
        return await this.userRepository.findById(id);
    }
    
    async createUser(name: string, email: string): Promise<void> {
        const user = new User(Date.now(), name, email);
        await this.userRepository.save(user);
    }
    
    async removeUser(id: number): Promise<void> {
        await this.userRepository.delete(id);
    }
}

// Easy to inject different implementations
const databaseRepo = new DatabaseUserRepository();
const userService = new UserService(databaseRepo);

// For testing, use in-memory implementation
const memoryRepo = new InMemoryUserRepository();
const testUserService = new UserService(memoryRepo);
```

## Benefits of SOLID Principles

### Code Quality Improvements

1. **Maintainability**: Code is easier to modify and extend
2. **Testability**: Individual components can be tested in isolation
3. **Flexibility**: Easy to swap implementations
4. **Reusability**: Components can be reused in different contexts
5. **Reduced Coupling**: Components are less dependent on each other

### Business Benefits

1. **Faster Development**: Well-structured code accelerates feature development
2. **Lower Maintenance Costs**: Less time spent fixing bugs and understanding code
3. **Better Team Collaboration**: Clear responsibilities and interfaces
4. **Easier Onboarding**: New developers can understand the codebase faster

## Common Violations and How to Fix Them

### God Class (SRP Violation)

```typescript
// ❌ God class doing everything
class UserManager {
    validateEmail(email: string): boolean { /* ... */ }
    hashPassword(password: string): string { /* ... */ }
    saveToDatabase(user: any): void { /* ... */ }
    sendEmail(email: string, message: string): void { /* ... */ }
    generateReport(): string { /* ... */ }
    logActivity(activity: string): void { /* ... */ }
}

// ✅ Split into focused classes
class EmailValidator { /* ... */ }
class PasswordHasher { /* ... */ }
class UserRepository { /* ... */ }
class EmailService { /* ... */ }
class ReportGenerator { /* ... */ }
class ActivityLogger { /* ... */ }
```

### Switch Statement Violations (OCP)

```typescript
// ❌ Switch statement that needs modification for new types
class ShapeCalculator {
    calculateArea(shape: any): number {
        switch (shape.type) {
            case 'circle':
                return Math.PI * shape.radius * shape.radius;
            case 'rectangle':
                return shape.width * shape.height;
            // Adding new shapes requires modifying this switch
            default:
                return 0;
        }
    }
}

// ✅ Use polymorphism instead
interface Shape {
    calculateArea(): number;
}

class Circle implements Shape {
    constructor(private radius: number) {}
    calculateArea(): number {
        return Math.PI * this.radius * this.radius;
    }
}

class Rectangle implements Shape {
    constructor(private width: number, private height: number) {}
    calculateArea(): number {
        return this.width * this.height;
    }
}
```

## SOLID in Different Languages

### Python Example

```python
# SRP Example in Python
class User:
    def __init__(self, name: str, email: str):
        self.name = name
        self.email = email

class EmailValidator:
    @staticmethod
    def validate(email: str) -> bool:
        import re
        pattern = r'^[^\s@]+@[^\s@]+\.[^\s@]+$'
        return re.match(pattern, email) is not None

class UserRepository:
    def save(self, user: User) -> None:
        print(f"Saving user {user.name} to database")

# OCP Example with Abstract Base Classes
from abc import ABC, abstractmethod

class PaymentProcessor(ABC):
    @abstractmethod
    def process_payment(self, amount: float) -> bool:
        pass

class CreditCardProcessor(PaymentProcessor):
    def process_payment(self, amount: float) -> bool:
        print(f"Processing ${amount} payment via credit card")
        return True

class PayPalProcessor(PaymentProcessor):
    def process_payment(self, amount: float) -> bool:
        print(f"Processing ${amount} payment via PayPal")
        return True
```

### Java Example

```java
// ISP Example in Java
interface Readable {
    String read();
}

interface Writable {
    void write(String data);
}

interface Executable {
    void execute();
}

class Document implements Readable, Writable {
    public String read() {
        return "Document content";
    }
    
    public void write(String data) {
        System.out.println("Writing: " + data);
    }
}

class Program implements Readable, Executable {
    public String read() {
        return "Program source code";
    }
    
    public void execute() {
        System.out.println("Executing program");
    }
}
```

## Real-World Application

### E-commerce System Example

```typescript
// Domain entities
class Product {
    constructor(
        public id: string,
        public name: string,
        public price: number,
        public stock: number
    ) {}
}

class Order {
    constructor(
        public id: string,
        public userId: string,
        public items: OrderItem[],
        public status: OrderStatus
    ) {}
}

class OrderItem {
    constructor(
        public productId: string,
        public quantity: number,
        public price: number
    ) {}
}

enum OrderStatus {
    PENDING = 'pending',
    CONFIRMED = 'confirmed',
    SHIPPED = 'shipped',
    DELIVERED = 'delivered'
}

// Repository interfaces (DIP)
interface ProductRepository {
    findById(id: string): Promise<Product | null>;
    updateStock(id: string, quantity: number): Promise<void>;
}

interface OrderRepository {
    save(order: Order): Promise<void>;
    findById(id: string): Promise<Order | null>;
}

// Service interfaces (ISP)
interface PaymentService {
    processPayment(amount: number, paymentMethod: string): Promise<boolean>;
}

interface NotificationService {
    sendOrderConfirmation(userId: string, orderId: string): Promise<void>;
}

interface InventoryService {
    reserveItems(items: OrderItem[]): Promise<boolean>;
    releaseItems(items: OrderItem[]): Promise<void>;
}

// Concrete implementations
class DatabaseProductRepository implements ProductRepository {
    async findById(id: string): Promise<Product | null> {
        // Database implementation
        return null;
    }
    
    async updateStock(id: string, quantity: number): Promise<void> {
        // Database implementation
    }
}

class StripePaymentService implements PaymentService {
    async processPayment(amount: number, paymentMethod: string): Promise<boolean> {
        console.log(`Processing $${amount} payment via Stripe`);
        return true;
    }
}

class EmailNotificationService implements NotificationService {
    async sendOrderConfirmation(userId: string, orderId: string): Promise<void> {
        console.log(`Sending order confirmation for ${orderId} to user ${userId}`);
    }
}

// Main service (SRP)
class OrderService {
    constructor(
        private orderRepository: OrderRepository,
        private productRepository: ProductRepository,
        private paymentService: PaymentService,
        private notificationService: NotificationService,
        private inventoryService: InventoryService
    ) {}
    
    async createOrder(userId: string, items: OrderItem[], paymentMethod: string): Promise<string> {
        // Validate inventory
        const inventoryReserved = await this.inventoryService.reserveItems(items);
        if (!inventoryReserved) {
            throw new Error('Insufficient inventory');
        }
        
        try {
            // Calculate total
            const total = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
            
            // Process payment
            const paymentSuccess = await this.paymentService.processPayment(total, paymentMethod);
            if (!paymentSuccess) {
                await this.inventoryService.releaseItems(items);
                throw new Error('Payment failed');
            }
            
            // Create order
            const orderId = this.generateOrderId();
            const order = new Order(orderId, userId, items, OrderStatus.CONFIRMED);
            await this.orderRepository.save(order);
            
            // Send notification
            await this.notificationService.sendOrderConfirmation(userId, orderId);
            
            return orderId;
        } catch (error) {
            await this.inventoryService.releaseItems(items);
            throw error;
        }
    }
    
    private generateOrderId(): string {
        return `ORDER_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}
```

## Best Practices

### 1. Start Small
- Apply SOLID principles gradually
- Focus on one principle at a time
- Refactor existing code incrementally

### 2. Use Design Patterns
- **Strategy Pattern** for OCP
- **Repository Pattern** for DIP
- **Factory Pattern** for object creation
- **Observer Pattern** for loose coupling

### 3. Dependency Injection
```typescript
// Use dependency injection containers
class DIContainer {
    private services = new Map<string, any>();
    
    register<T>(key: string, implementation: T): void {
        this.services.set(key, implementation);
    }
    
    resolve<T>(key: string): T {
        return this.services.get(key);
    }
}

// Register services
const container = new DIContainer();
container.register('userRepository', new DatabaseUserRepository());
container.register('emailService', new EmailService());

// Resolve dependencies
const userRepo = container.resolve<UserRepository>('userRepository');
const emailSvc = container.resolve<NotificationService>('emailService');
const userService = new UserService(userRepo, emailSvc);
```

### 4. Testing Strategy
```typescript
// Mock implementations for testing
class MockUserRepository implements UserRepository {
    private users: User[] = [];
    
    async findById(id: number): Promise<User | null> {
        return this.users.find(u => u.id === id) || null;
    }
    
    async save(user: User): Promise<void> {
        this.users.push(user);
    }
}

// Easy to test with dependency injection
describe('UserService', () => {
    let userService: UserService;
    let mockRepo: MockUserRepository;
    
    beforeEach(() => {
        mockRepo = new MockUserRepository();
        userService = new UserService(mockRepo);
    });
    
    it('should create user successfully', async () => {
        await userService.createUser('John', 'john@example.com');
        const user = await mockRepo.findById(1);
        expect(user?.name).toBe('John');
    });
});
```

### 5. Code Review Checklist
- [ ] Each class has a single responsibility
- [ ] New functionality can be added without modifying existing code
- [ ] Subclasses can replace parent classes without breaking functionality
- [ ] Interfaces are small and focused
- [ ] High-level modules depend on abstractions, not concretions

## Conclusion

SOLID principles are fundamental guidelines that help create maintainable, flexible, and robust software systems. While they may seem complex at first, applying them consistently leads to:

- **Better code organization** with clear responsibilities
- **Easier testing** through dependency injection and isolation
- **Improved maintainability** with loose coupling and high cohesion
- **Enhanced flexibility** for future changes and extensions

Remember that SOLID principles are guidelines, not rigid rules. Use them judiciously and adapt them to your specific context and requirements. The goal is to create code that is easy to understand, modify, and extend over time.

<BackToTop />
