import BackToTop from "@/components/BackToTop";

# Software Design Principles

## Table of Contents

## Introduction to Software Design Principles

Software design principles are fundamental guidelines that help developers create software that is efficient, maintainable, and scalable. These principles provide a framework for making design decisions and ensure that the software architecture is robust and adaptable to future changes. By following these principles, developers can improve code quality, reduce complexity, and enhance collaboration within development teams.

Software design principles encompass various aspects of software development, including modularity, abstraction, encapsulation, and separation of concerns. They guide developers in structuring code, defining interfaces, and managing dependencies. These principles are not strict rules but rather best practices that can be applied to different programming paradigms and technologies. They help in creating software that is easier to understand, test, and maintain over time.

The evolution of software design principles has been driven by decades of experience in building complex software systems. From the early days of structured programming to modern microservices architectures, these principles have proven their value in creating robust, maintainable software solutions.

## Core Design Principles

### Modularity

Modularity is the principle of breaking down a software system into smaller, manageable components or modules. Each module should have a specific responsibility and can be developed, tested, and maintained independently. This approach promotes code reuse, simplifies debugging, and enhances collaboration among developers.

#### Benefits of Modularity

1. **Improved Maintainability**: Changes to one module don't affect others
2. **Enhanced Testability**: Modules can be tested in isolation
3. **Better Collaboration**: Teams can work on different modules simultaneously
4. **Code Reusability**: Modules can be reused across different projects
5. **Easier Debugging**: Issues can be isolated to specific modules

#### Modular Design Example

```typescript
// ❌ Monolithic approach
class ECommerceSystem {
  processPayment(amount: number, cardInfo: any): boolean {
    // Payment processing logic
    console.log("Processing payment...");
    return true;
  }

  sendEmail(to: string, subject: string, body: string): void {
    // Email sending logic
    console.log("Sending email...");
  }

  updateInventory(productId: string, quantity: number): void {
    // Inventory management logic
    console.log("Updating inventory...");
  }

  calculateShipping(weight: number, destination: string): number {
    // Shipping calculation logic
    return 10.99;
  }
}

// ✅ Modular approach
// Payment Module
interface PaymentProcessor {
  processPayment(
    amount: number,
    paymentMethod: PaymentMethod
  ): Promise<PaymentResult>;
}

class StripePaymentProcessor implements PaymentProcessor {
  async processPayment(
    amount: number,
    paymentMethod: PaymentMethod
  ): Promise<PaymentResult> {
    console.log(`Processing $${amount} payment via Stripe`);
    return { success: true, transactionId: "stripe_123" };
  }
}

// Email Module
interface EmailService {
  sendEmail(emailRequest: EmailRequest): Promise<void>;
}

class SendGridEmailService implements EmailService {
  async sendEmail(emailRequest: EmailRequest): Promise<void> {
    console.log(`Sending email to ${emailRequest.to}`);
  }
}

// Inventory Module
interface InventoryManager {
  updateStock(productId: string, quantity: number): Promise<void>;
  checkAvailability(productId: string, quantity: number): Promise<boolean>;
}

class DatabaseInventoryManager implements InventoryManager {
  async updateStock(productId: string, quantity: number): Promise<void> {
    console.log(`Updating stock for ${productId}: ${quantity}`);
  }

  async checkAvailability(
    productId: string,
    quantity: number
  ): Promise<boolean> {
    console.log(`Checking availability for ${productId}: ${quantity}`);
    return true;
  }
}

// Shipping Module
interface ShippingCalculator {
  calculateShippingCost(request: ShippingRequest): Promise<number>;
}

class FedExShippingCalculator implements ShippingCalculator {
  async calculateShippingCost(request: ShippingRequest): Promise<number> {
    console.log(`Calculating shipping cost for ${request.destination}`);
    return 12.99;
  }
}

// Main orchestrator
class ModularECommerceSystem {
  constructor(
    private paymentProcessor: PaymentProcessor,
    private emailService: EmailService,
    private inventoryManager: InventoryManager,
    private shippingCalculator: ShippingCalculator
  ) {}

  async processOrder(order: Order): Promise<OrderResult> {
    // Orchestrate the modules
    const shippingCost = await this.shippingCalculator.calculateShippingCost({
      weight: order.totalWeight,
      destination: order.shippingAddress,
    });

    const paymentResult = await this.paymentProcessor.processPayment(
      order.total + shippingCost,
      order.paymentMethod
    );

    if (paymentResult.success) {
      await this.inventoryManager.updateStock(
        order.items[0].productId,
        order.items[0].quantity
      );
      await this.emailService.sendEmail({
        to: order.customerEmail,
        subject: "Order Confirmation",
        body: `Your order ${order.id} has been processed successfully.`,
      });
    }

    return { success: paymentResult.success, orderId: order.id };
  }
}
```

#### Module Organization Strategies

```typescript
// Feature-based modules
src / modules / user / user.service.ts;
user.repository.ts;
user.controller.ts;
user.model.ts;
user.types.ts;
product / product.service.ts;
product.repository.ts;
product.controller.ts;
product.model.ts;
order / order.service.ts;
order.repository.ts;
order.controller.ts;
order.model.ts;

// Layer-based modules
src / controllers / user.controller.ts;
product.controller.ts;
order.controller.ts;
services / user.service.ts;
product.service.ts;
order.service.ts;
repositories / user.repository.ts;
product.repository.ts;
order.repository.ts;
models / user.model.ts;
product.model.ts;
order.model.ts;
```

<BackToTop />

### Abstraction

Abstraction is the principle of simplifying complex systems by focusing on the essential features while hiding unnecessary details. It allows developers to create models or representations of real-world entities, making it easier to understand and manipulate the software.

#### Levels of Abstraction

1. **Data Abstraction**: Hiding implementation details of data structures
2. **Procedural Abstraction**: Hiding implementation details of functions
3. **Control Abstraction**: Hiding implementation details of control structures
4. **Object Abstraction**: Hiding implementation details of objects

#### Abstraction Examples

```typescript
// ❌ Low-level, concrete implementation
class FileReader {
  readFile(path: string): string {
    // Direct file system operations
    const fs = require("fs");
    const buffer = fs.readFileSync(path);
    const content = buffer.toString("utf8");
    console.log(`Read ${content.length} characters from ${path}`);
    return content;
  }
}

// ✅ High-level abstraction
interface DataSource {
  read(): Promise<string>;
}

class FileDataSource implements DataSource {
  constructor(private filePath: string) {}

  async read(): Promise<string> {
    // Hide file system complexity
    const fs = require("fs").promises;
    return await fs.readFile(this.filePath, "utf8");
  }
}

class DatabaseDataSource implements DataSource {
  constructor(private query: string) {}

  async read(): Promise<string> {
    // Hide database complexity
    console.log(`Executing query: ${this.query}`);
    return "Database result";
  }
}

class APIDataSource implements DataSource {
  constructor(private url: string) {}

  async read(): Promise<string> {
    // Hide HTTP complexity
    console.log(`Fetching data from: ${this.url}`);
    return "API response";
  }
}

// Consumer works with abstraction, not concrete implementations
class DataProcessor {
  constructor(private dataSource: DataSource) {}

  async processData(): Promise<ProcessedData> {
    const rawData = await this.dataSource.read();
    // Process data regardless of source
    return { processed: true, data: rawData };
  }
}
```

#### Abstract Factory Pattern Example

```typescript
// Abstract product interfaces
interface Database {
  connect(): void;
  query(sql: string): any[];
}

interface Cache {
  get(key: string): any;
  set(key: string, value: any): void;
}

// Abstract factory interface
interface DataAccessFactory {
  createDatabase(): Database;
  createCache(): Cache;
}

// Concrete implementations for MySQL
class MySQLDatabase implements Database {
  connect(): void {
    console.log("Connecting to MySQL database");
  }

  query(sql: string): any[] {
    console.log(`Executing MySQL query: ${sql}`);
    return [];
  }
}

class RedisCache implements Cache {
  get(key: string): any {
    console.log(`Getting value for key: ${key} from Redis`);
    return null;
  }

  set(key: string, value: any): void {
    console.log(`Setting key: ${key} in Redis`);
  }
}

// Concrete factory for MySQL stack
class MySQLDataAccessFactory implements DataAccessFactory {
  createDatabase(): Database {
    return new MySQLDatabase();
  }

  createCache(): Cache {
    return new RedisCache();
  }
}

// Client code works with abstractions
class Application {
  private database: Database;
  private cache: Cache;

  constructor(factory: DataAccessFactory) {
    this.database = factory.createDatabase();
    this.cache = factory.createCache();
  }

  run(): void {
    this.database.connect();
    this.cache.set("config", { theme: "dark" });
    const data = this.database.query("SELECT * FROM users");
    console.log("Application running with abstract components");
  }
}
```

<BackToTop />

### Encapsulation

Encapsulation is the principle of bundling data and methods that operate on that data within a single unit, such as a class or module. It restricts direct access to the internal state of the object and provides a controlled interface for interacting with it.

#### Encapsulation Benefits

1. **Data Protection**: Internal state is protected from external modification
2. **Interface Stability**: Internal changes don't affect external code
3. **Easier Maintenance**: Implementation can be changed without affecting clients
4. **Better Debugging**: State changes are controlled and traceable

#### Encapsulation Examples

```typescript
// ❌ Poor encapsulation - direct access to properties
class BankAccount {
  public balance: number;
  public accountNumber: string;

  constructor(accountNumber: string, initialBalance: number) {
    this.accountNumber = accountNumber;
    this.balance = initialBalance;
  }
}

const account = new BankAccount("123456", 1000);
account.balance = -500; // Oops! Negative balance allowed
account.accountNumber = "HACKED"; // Account number can be changed

// ✅ Proper encapsulation
class SecureBankAccount {
  private _balance: number;
  private readonly _accountNumber: string;
  private _transactionHistory: Transaction[] = [];

  constructor(accountNumber: string, initialBalance: number) {
    this._accountNumber = accountNumber;
    this._balance = this.validateBalance(initialBalance);
  }

  // Controlled access to balance
  get balance(): number {
    return this._balance;
  }

  // Read-only access to account number
  get accountNumber(): string {
    return this._accountNumber;
  }

  // Controlled deposit operation
  deposit(amount: number): boolean {
    if (amount <= 0) {
      throw new Error("Deposit amount must be positive");
    }

    this._balance += amount;
    this._transactionHistory.push({
      type: "deposit",
      amount,
      timestamp: new Date(),
      balanceAfter: this._balance,
    });

    return true;
  }

  // Controlled withdrawal operation
  withdraw(amount: number): boolean {
    if (amount <= 0) {
      throw new Error("Withdrawal amount must be positive");
    }

    if (amount > this._balance) {
      throw new Error("Insufficient funds");
    }

    this._balance -= amount;
    this._transactionHistory.push({
      type: "withdrawal",
      amount,
      timestamp: new Date(),
      balanceAfter: this._balance,
    });

    return true;
  }

  // Controlled access to transaction history
  getTransactionHistory(): ReadonlyArray<Transaction> {
    return [...this._transactionHistory]; // Return copy, not reference
  }

  private validateBalance(balance: number): number {
    if (balance < 0) {
      throw new Error("Initial balance cannot be negative");
    }
    return balance;
  }
}

interface Transaction {
  type: "deposit" | "withdrawal";
  amount: number;
  timestamp: Date;
  balanceAfter: number;
}
```

#### Advanced Encapsulation with Modules

```typescript
// Module-level encapsulation
const UserModule = (() => {
  // Private variables (not accessible outside)
  const users: Map<string, User> = new Map();
  let nextId = 1;

  // Private functions
  function generateId(): string {
    return `user_${nextId++}`;
  }

  function validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  // Public API
  return {
    createUser(name: string, email: string): User {
      if (!validateEmail(email)) {
        throw new Error("Invalid email format");
      }

      const id = generateId();
      const user = new User(id, name, email);
      users.set(id, user);
      return user;
    },

    getUser(id: string): User | undefined {
      return users.get(id);
    },

    getUserCount(): number {
      return users.size;
    },

    // Don't expose internal users map
    getAllUsers(): User[] {
      return Array.from(users.values());
    },
  };
})();
```

<BackToTop />

### Separation of Concerns

Separation of concerns is the principle of dividing a software system into distinct sections, each addressing a specific concern or functionality. This approach helps in organizing code, improving maintainability, and reducing complexity.

#### Types of Separation

1. **Horizontal Separation**: Separating by layers (presentation, business, data)
2. **Vertical Separation**: Separating by features or domains
3. **Cross-cutting Concerns**: Separating aspects like logging, security, caching

#### Layered Architecture Example

```typescript
// ❌ Mixed concerns - everything in one place
class UserController {
  handleCreateUser(request: any): any {
    // Validation mixed with business logic
    if (!request.email || !request.name) {
      return { error: "Missing required fields" };
    }

    // Database logic mixed with business logic
    const connection = mysql.createConnection({
      host: "localhost",
      user: "root",
      database: "myapp",
    });

    // Business logic mixed with data access
    const hashedPassword = bcrypt.hash(request.password, 10);
    const query = `INSERT INTO users (name, email, password) VALUES (?, ?, ?)`;
    connection.query(query, [request.name, request.email, hashedPassword]);

    // Email logic mixed with everything else
    const transporter = nodemailer.createTransporter(/* config */);
    transporter.sendMail({
      to: request.email,
      subject: "Welcome!",
      text: "Welcome to our app!",
    });

    return { success: true };
  }
}

// ✅ Separated concerns - each layer has specific responsibility

// 1. Presentation Layer
class UserController {
  constructor(
    private userService: UserService,
    private validator: RequestValidator
  ) {}

  async createUser(request: CreateUserRequest): Promise<ApiResponse<User>> {
    try {
      // Only handle HTTP concerns
      const validation = this.validator.validate(request);
      if (!validation.isValid) {
        return {
          success: false,
          error: validation.errors,
          statusCode: 400,
        };
      }

      const user = await this.userService.createUser(request);
      return {
        success: true,
        data: user,
        statusCode: 201,
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        statusCode: 500,
      };
    }
  }
}

// 2. Business Logic Layer
class UserService {
  constructor(
    private userRepository: UserRepository,
    private emailService: EmailService,
    private passwordService: PasswordService
  ) {}

  async createUser(request: CreateUserRequest): Promise<User> {
    // Only handle business logic
    const existingUser = await this.userRepository.findByEmail(request.email);
    if (existingUser) {
      throw new Error("User already exists");
    }

    const hashedPassword = await this.passwordService.hash(request.password);
    const user = new User(
      this.generateId(),
      request.name,
      request.email,
      hashedPassword
    );

    const savedUser = await this.userRepository.save(user);

    // Trigger welcome email (business rule)
    await this.emailService.sendWelcomeEmail(savedUser);

    return savedUser;
  }

  private generateId(): string {
    return `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// 3. Data Access Layer
class UserRepository {
  constructor(private database: Database) {}

  async findByEmail(email: string): Promise<User | null> {
    // Only handle data access concerns
    const query = "SELECT * FROM users WHERE email = ?";
    const result = await this.database.query(query, [email]);
    return result.length > 0 ? this.mapToUser(result[0]) : null;
  }

  async save(user: User): Promise<User> {
    const query = `
            INSERT INTO users (id, name, email, password, created_at) 
            VALUES (?, ?, ?, ?, ?)
        `;
    await this.database.query(query, [
      user.id,
      user.name,
      user.email,
      user.password,
      user.createdAt,
    ]);
    return user;
  }

  private mapToUser(row: any): User {
    return new User(row.id, row.name, row.email, row.password, row.created_at);
  }
}

// 4. Infrastructure Layer
class EmailService {
  constructor(private emailProvider: EmailProvider) {}

  async sendWelcomeEmail(user: User): Promise<void> {
    // Only handle email sending concerns
    const emailContent = {
      to: user.email,
      subject: "Welcome to Our App!",
      template: "welcome",
      data: { userName: user.name },
    };

    await this.emailProvider.send(emailContent);
  }
}

class PasswordService {
  async hash(password: string): Promise<string> {
    // Only handle password hashing concerns
    const saltRounds = 12;
    return await bcrypt.hash(password, saltRounds);
  }

  async verify(password: string, hash: string): Promise<boolean> {
    return await bcrypt.compare(password, hash);
  }
}
```

<BackToTop />

### Don't Repeat Yourself (DRY)

The DRY principle states that "every piece of knowledge must have a single, unambiguous, authoritative representation within a system." It aims to reduce repetition of software patterns.

#### DRY Examples

```typescript
// ❌ Violation of DRY - Repeated validation logic
class UserController {
  createUser(userData: any): any {
    if (!userData.email || userData.email.length === 0) {
      return { error: "Email is required" };
    }
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(userData.email)) {
      return { error: "Invalid email format" };
    }
    if (!userData.name || userData.name.length < 2) {
      return { error: "Name must be at least 2 characters" };
    }
    // Create user logic...
  }

  updateUser(userData: any): any {
    if (!userData.email || userData.email.length === 0) {
      return { error: "Email is required" };
    }
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(userData.email)) {
      return { error: "Invalid email format" };
    }
    if (!userData.name || userData.name.length < 2) {
      return { error: "Name must be at least 2 characters" };
    }
    // Update user logic...
  }
}

// ✅ Following DRY - Extracted common validation
class ValidationService {
  static validateEmail(email: string): ValidationResult {
    if (!email || email.length === 0) {
      return { isValid: false, error: "Email is required" };
    }
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return { isValid: false, error: "Invalid email format" };
    }
    return { isValid: true };
  }

  static validateName(name: string): ValidationResult {
    if (!name || name.length < 2) {
      return { isValid: false, error: "Name must be at least 2 characters" };
    }
    return { isValid: true };
  }

  static validateUser(userData: UserData): ValidationResult {
    const emailValidation = this.validateEmail(userData.email);
    if (!emailValidation.isValid) return emailValidation;

    const nameValidation = this.validateName(userData.name);
    if (!nameValidation.isValid) return nameValidation;

    return { isValid: true };
  }
}

class UserController {
  createUser(userData: UserData): any {
    const validation = ValidationService.validateUser(userData);
    if (!validation.isValid) {
      return { error: validation.error };
    }
    // Create user logic...
  }

  updateUser(userData: UserData): any {
    const validation = ValidationService.validateUser(userData);
    if (!validation.isValid) {
      return { error: validation.error };
    }
    // Update user logic...
  }
}
```

<BackToTop />

### Keep It Simple, Stupid (KISS)

The KISS principle states that most systems work best if they are kept simple rather than made complicated. Simplicity should be a key goal in design.

#### KISS Examples

```typescript
// ❌ Over-complicated solution
class ComplexDateFormatter {
  private formatters: Map<string, (date: Date) => string> = new Map();
  private defaultFormat: string = "YYYY-MM-DD";

  constructor() {
    this.initializeFormatters();
  }

  private initializeFormatters(): void {
    this.formatters.set("ISO", (date: Date) => date.toISOString());
    this.formatters.set("US", (date: Date) => {
      const month = (date.getMonth() + 1).toString().padStart(2, "0");
      const day = date.getDate().toString().padStart(2, "0");
      const year = date.getFullYear();
      return `${month}/${day}/${year}`;
    });
    // ... many more formatters
  }

  formatDate(date: Date, format?: string): string {
    const selectedFormat = format || this.defaultFormat;
    const formatter = this.formatters.get(selectedFormat);

    if (!formatter) {
      throw new Error(`Unsupported format: ${selectedFormat}`);
    }

    return formatter(date);
  }
}

// ✅ Simple, direct solution
class SimpleDateFormatter {
  static formatDate(
    date: Date,
    format: "ISO" | "US" | "default" = "default"
  ): string {
    switch (format) {
      case "ISO":
        return date.toISOString();
      case "US":
        return date.toLocaleDateString("en-US");
      default:
        return date.toISOString().split("T")[0]; // YYYY-MM-DD
    }
  }
}

// Even simpler for basic use cases
const formatDate = (date: Date) => date.toISOString().split("T")[0];
```

<BackToTop />

### You Aren't Gonna Need It (YAGNI)

YAGNI is a principle that states you should not add functionality until it's actually needed. It prevents over-engineering and focuses development effort on current requirements.

#### YAGNI Examples

```typescript
// ❌ Over-engineering - building for future requirements that may never come
class OverEngineeredUserService {
  // Complex caching system for users (not currently needed)
  private userCache: Map<string, User> = new Map();
  private cacheExpiry: Map<string, number> = new Map();
  private cacheStrategy: "LRU" | "LFU" | "FIFO" = "LRU";

  // Complex notification system (not currently needed)
  private notificationQueue: NotificationQueue[] = [];
  private notificationStrategies: Map<string, NotificationStrategy> = new Map();

  // Complex audit logging (not currently needed)
  private auditLogger: AuditLogger;
  private auditConfig: AuditConfiguration;

  // Multiple database support (only using one database)
  private primaryDb: Database;
  private secondaryDb?: Database;
  private readReplicas: Database[] = [];

  constructor(config: ComplexUserServiceConfig) {
    this.setupCaching(config.cache);
    this.setupNotifications(config.notifications);
    this.setupAuditing(config.audit);
    this.setupDatabases(config.databases);
  }

  async createUser(userData: UserData): Promise<User> {
    // Lots of complex logic for features not currently needed
    const user =
      await this.createUserWithAuditingAndCachingAndNotifications(userData);
    return user;
  }

  // Many more complex methods...
}

// ✅ Simple solution focused on current needs
class SimpleUserService {
  constructor(private userRepository: UserRepository) {}

  async createUser(userData: UserData): Promise<User> {
    const user = new User(this.generateId(), userData.name, userData.email);

    return await this.userRepository.save(user);
  }

  async getUser(id: string): Promise<User | null> {
    return await this.userRepository.findById(id);
  }

  private generateId(): string {
    return Date.now().toString();
  }
}

// Add complexity only when needed:
// - Add caching when performance becomes an issue
// - Add notifications when the business requires them
// - Add audit logging when compliance requires it
// - Add multiple database support when scaling requires it
```

<BackToTop />

## Design Patterns

Design patterns are reusable solutions to common software design problems. They provide a proven approach to solving specific design challenges and can be applied across different programming languages and paradigms.

### Creational Patterns

#### Singleton Pattern

```typescript
// ✅ Thread-safe Singleton implementation
class ConfigurationManager {
  private static instance: ConfigurationManager;
  private config: Map<string, any> = new Map();

  private constructor() {
    this.loadConfiguration();
  }

  public static getInstance(): ConfigurationManager {
    if (!ConfigurationManager.instance) {
      ConfigurationManager.instance = new ConfigurationManager();
    }
    return ConfigurationManager.instance;
  }

  private loadConfiguration(): void {
    // Load configuration from environment, files, etc.
    this.config.set("apiUrl", process.env.API_URL || "http://localhost:3000");
    this.config.set(
      "dbConnection",
      process.env.DB_CONNECTION || "mongodb://localhost:27017"
    );
  }

  public get(key: string): any {
    return this.config.get(key);
  }

  public set(key: string, value: any): void {
    this.config.set(key, value);
  }
}

// Usage
const config = ConfigurationManager.getInstance();
const apiUrl = config.get("apiUrl");
```

#### Factory Pattern

```typescript
// Product interface
interface Logger {
  log(message: string): void;
}

// Concrete products
class FileLogger implements Logger {
  constructor(private filename: string) {}

  log(message: string): void {
    console.log(
      `[FILE ${this.filename}] ${new Date().toISOString()}: ${message}`
    );
  }
}

class DatabaseLogger implements Logger {
  constructor(private connectionString: string) {}

  log(message: string): void {
    console.log(
      `[DB ${this.connectionString}] ${new Date().toISOString()}: ${message}`
    );
  }
}

class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(`[CONSOLE] ${new Date().toISOString()}: ${message}`);
  }
}

// Factory
class LoggerFactory {
  static createLogger(
    type: "file" | "database" | "console",
    config?: any
  ): Logger {
    switch (type) {
      case "file":
        return new FileLogger(config?.filename || "app.log");
      case "database":
        return new DatabaseLogger(
          config?.connectionString || "default-connection"
        );
      case "console":
        return new ConsoleLogger();
      default:
        throw new Error(`Unknown logger type: ${type}`);
    }
  }
}

// Usage
const logger = LoggerFactory.createLogger("file", { filename: "errors.log" });
logger.log("Application started");
```

<BackToTop />

### Behavioral Patterns

#### Observer Pattern

```typescript
// Subject interface
interface Subject {
  subscribe(observer: Observer): void;
  unsubscribe(observer: Observer): void;
  notify(event: Event): void;
}

// Observer interface
interface Observer {
  update(event: Event): void;
}

// Concrete subject
class EventBus implements Subject {
  private observers: Observer[] = [];

  subscribe(observer: Observer): void {
    this.observers.push(observer);
  }

  unsubscribe(observer: Observer): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  notify(event: Event): void {
    this.observers.forEach((observer) => observer.update(event));
  }
}

// Concrete observers
class EmailNotificationService implements Observer {
  update(event: Event): void {
    if (event.type === "user-created") {
      console.log(`Sending welcome email to ${event.data.email}`);
    }
  }
}

class AuditLogger implements Observer {
  update(event: Event): void {
    console.log(`Audit log: ${event.type} at ${event.timestamp}`);
  }
}

class AnalyticsService implements Observer {
  update(event: Event): void {
    if (event.type === "user-created") {
      console.log("Incrementing user registration metrics");
    }
  }
}

// Usage
const eventBus = new EventBus();
const emailService = new EmailNotificationService();
const auditLogger = new AuditLogger();
const analytics = new AnalyticsService();

eventBus.subscribe(emailService);
eventBus.subscribe(auditLogger);
eventBus.subscribe(analytics);

// When a user is created
eventBus.notify({
  type: "user-created",
  data: { id: "123", email: "user@example.com" },
  timestamp: new Date(),
});
```

#### Strategy Pattern

```typescript
// Strategy interface
interface PricingStrategy {
  calculatePrice(basePrice: number): number;
}

// Concrete strategies
class RegularPricing implements PricingStrategy {
  calculatePrice(basePrice: number): number {
    return basePrice;
  }
}

class DiscountPricing implements PricingStrategy {
  constructor(private discountPercentage: number) {}

  calculatePrice(basePrice: number): number {
    return basePrice * (1 - this.discountPercentage / 100);
  }
}

class PremiumPricing implements PricingStrategy {
  constructor(private premiumMultiplier: number) {}

  calculatePrice(basePrice: number): number {
    return basePrice * this.premiumMultiplier;
  }
}

class SeasonalPricing implements PricingStrategy {
  constructor(private seasonMultiplier: number) {}

  calculatePrice(basePrice: number): number {
    return basePrice * this.seasonMultiplier;
  }
}

// Context
class PriceCalculator {
  constructor(private strategy: PricingStrategy) {}

  setStrategy(strategy: PricingStrategy): void {
    this.strategy = strategy;
  }

  calculateFinalPrice(basePrice: number): number {
    return this.strategy.calculatePrice(basePrice);
  }
}

// Usage
const calculator = new PriceCalculator(new RegularPricing());
console.log(calculator.calculateFinalPrice(100)); // 100

calculator.setStrategy(new DiscountPricing(20));
console.log(calculator.calculateFinalPrice(100)); // 80

calculator.setStrategy(new PremiumPricing(1.5));
console.log(calculator.calculateFinalPrice(100)); // 150
```

<BackToTop />

### Structural Patterns

#### Decorator Pattern

```typescript
// Component interface
interface Coffee {
  getCost(): number;
  getDescription(): string;
}

// Concrete component
class SimpleCoffee implements Coffee {
  getCost(): number {
    return 2.0;
  }

  getDescription(): string {
    return "Simple coffee";
  }
}

// Decorator base class
abstract class CoffeeDecorator implements Coffee {
  constructor(protected coffee: Coffee) {}

  getCost(): number {
    return this.coffee.getCost();
  }

  getDescription(): string {
    return this.coffee.getDescription();
  }
}

// Concrete decorators
class MilkDecorator extends CoffeeDecorator {
  getCost(): number {
    return this.coffee.getCost() + 0.5;
  }

  getDescription(): string {
    return this.coffee.getDescription() + ", milk";
  }
}

class SugarDecorator extends CoffeeDecorator {
  getCost(): number {
    return this.coffee.getCost() + 0.2;
  }

  getDescription(): string {
    return this.coffee.getDescription() + ", sugar";
  }
}

class WhipDecorator extends CoffeeDecorator {
  getCost(): number {
    return this.coffee.getCost() + 0.7;
  }

  getDescription(): string {
    return this.coffee.getDescription() + ", whip";
  }
}

// Usage
let coffee: Coffee = new SimpleCoffee();
console.log(`${coffee.getDescription()} costs $${coffee.getCost()}`);

coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);
coffee = new WhipDecorator(coffee);

console.log(`${coffee.getDescription()} costs $${coffee.getCost()}`);
// Output: "Simple coffee, milk, sugar, whip costs $3.4"
```

<BackToTop />

## Common Anti-Patterns

### God Object

```typescript
// ❌ God Object - does everything
class ApplicationManager {
  // User management
  createUser() {
    /* ... */
  }
  updateUser() {
    /* ... */
  }
  deleteUser() {
    /* ... */
  }

  // Product management
  createProduct() {
    /* ... */
  }
  updateProduct() {
    /* ... */
  }
  deleteProduct() {
    /* ... */
  }

  // Order processing
  processOrder() {
    /* ... */
  }
  cancelOrder() {
    /* ... */
  }

  // Payment processing
  processPayment() {
    /* ... */
  }
  refundPayment() {
    /* ... */
  }

  // Email notifications
  sendEmail() {
    /* ... */
  }

  // Database operations
  saveToDatabase() {
    /* ... */
  }
  readFromDatabase() {
    /* ... */
  }

  // File operations
  saveToFile() {
    /* ... */
  }
  readFromFile() {
    /* ... */
  }

  // Logging
  logInfo() {
    /* ... */
  }
  logError() {
    /* ... */
  }

  // Configuration
  loadConfig() {
    /* ... */
  }
  saveConfig() {
    /* ... */
  }
}

// ✅ Separated responsibilities
class UserService {
  /* user-specific methods */
}
class ProductService {
  /* product-specific methods */
}
class OrderService {
  /* order-specific methods */
}
class PaymentService {
  /* payment-specific methods */
}
class EmailService {
  /* email-specific methods */
}
class DatabaseService {
  /* database-specific methods */
}
class FileService {
  /* file-specific methods */
}
class Logger {
  /* logging-specific methods */
}
class ConfigurationService {
  /* config-specific methods */
}
```

### Spaghetti Code

```typescript
// ❌ Spaghetti code - tangled dependencies and logic
function processUserOrder(userId, productId, quantity, paymentInfo) {
  let user = getUserFromDatabase(userId);
  if (user) {
    let product = getProductFromDatabase(productId);
    if (product && product.stock >= quantity) {
      if (paymentInfo.type === "credit") {
        if (validateCreditCard(paymentInfo.cardNumber)) {
          let charge = chargeCreditCard(paymentInfo, product.price * quantity);
          if (charge.success) {
            updateProductStock(productId, product.stock - quantity);
            let order = createOrder(userId, productId, quantity);
            sendConfirmationEmail(user.email, order);
            logOrderCreated(order);
            return { success: true, orderId: order.id };
          } else {
            logPaymentFailed(charge.error);
            return { success: false, error: "Payment failed" };
          }
        } else {
          return { success: false, error: "Invalid credit card" };
        }
      } else if (paymentInfo.type === "paypal") {
        // Similar nested logic for PayPal...
      }
    } else {
      return { success: false, error: "Insufficient stock" };
    }
  } else {
    return { success: false, error: "User not found" };
  }
}

// ✅ Clean, structured code
class OrderProcessor {
  constructor(
    private userService: UserService,
    private productService: ProductService,
    private paymentService: PaymentService,
    private orderService: OrderService,
    private emailService: EmailService,
    private logger: Logger
  ) {}

  async processOrder(request: OrderRequest): Promise<OrderResult> {
    try {
      await this.validateOrder(request);
      const payment = await this.processPayment(request);
      const order = await this.createOrder(request);
      await this.sendNotifications(order);

      this.logger.info(`Order ${order.id} processed successfully`);
      return { success: true, orderId: order.id };
    } catch (error) {
      this.logger.error(`Order processing failed: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  private async validateOrder(request: OrderRequest): Promise<void> {
    const user = await this.userService.getUser(request.userId);
    if (!user) throw new Error("User not found");

    const product = await this.productService.getProduct(request.productId);
    if (!product) throw new Error("Product not found");

    if (product.stock < request.quantity) {
      throw new Error("Insufficient stock");
    }
  }

  private async processPayment(request: OrderRequest): Promise<Payment> {
    return await this.paymentService.processPayment({
      amount: request.totalAmount,
      paymentMethod: request.paymentInfo,
    });
  }

  private async createOrder(request: OrderRequest): Promise<Order> {
    return await this.orderService.createOrder(request);
  }

  private async sendNotifications(order: Order): Promise<void> {
    await this.emailService.sendOrderConfirmation(order);
  }
}
```

<BackToTop />

## Best Practices

### 1. Progressive Enhancement

```typescript
// Start simple, add complexity when needed
class UserService {
  // Phase 1: Basic functionality
  async createUser(userData: UserData): Promise<User> {
    return await this.userRepository.save(new User(userData));
  }

  // Phase 2: Add validation when needed
  async createUserWithValidation(userData: UserData): Promise<User> {
    this.validateUserData(userData);
    return await this.userRepository.save(new User(userData));
  }

  // Phase 3: Add caching when performance becomes an issue
  async createUserWithCaching(userData: UserData): Promise<User> {
    this.validateUserData(userData);
    const user = new User(userData);
    const savedUser = await this.userRepository.save(user);
    await this.cache.set(user.id, savedUser);
    return savedUser;
  }
}
```

### 2. Composition Over Inheritance

```typescript
// ❌ Deep inheritance hierarchy
class Animal {
  move() {
    console.log("Moving");
  }
}

class Mammal extends Animal {
  breathe() {
    console.log("Breathing air");
  }
}

class FlyingMammal extends Mammal {
  fly() {
    console.log("Flying");
  }
}

class Bat extends FlyingMammal {
  echolocate() {
    console.log("Echolocating");
  }
}

// ✅ Composition-based approach
interface Movable {
  move(): void;
}

interface Breathable {
  breathe(): void;
}

interface Flyable {
  fly(): void;
}

interface Echolocatable {
  echolocate(): void;
}

class Bat implements Movable, Breathable, Flyable, Echolocatable {
  private movement = new GroundMovement();
  private breathing = new AirBreathing();
  private flight = new WingFlight();
  private echolocation = new UltrasonicEcholocation();

  move(): void {
    this.movement.move();
  }

  breathe(): void {
    this.breathing.breathe();
  }

  fly(): void {
    this.flight.fly();
  }

  echolocate(): void {
    this.echolocation.echolocate();
  }
}
```

### 3. Interface Segregation in Practice

```typescript
// ✅ Small, focused interfaces
interface Readable {
  read(): string;
}

interface Writable {
  write(data: string): void;
}

interface Seekable {
  seek(position: number): void;
}

// Compose interfaces as needed
class FileStream implements Readable, Writable, Seekable {
  read(): string {
    return "data";
  }
  write(data: string): void {
    console.log(`Writing: ${data}`);
  }
  seek(position: number): void {
    console.log(`Seeking to: ${position}`);
  }
}

class ReadOnlyFile implements Readable {
  read(): string {
    return "data";
  }
  // No write or seek methods needed
}

class NetworkStream implements Readable, Writable {
  read(): string {
    return "network data";
  }
  write(data: string): void {
    console.log(`Sending: ${data}`);
  }
  // No seek method - not applicable for network streams
}
```

### 4. Dependency Injection Best Practices

```typescript
// ✅ Constructor injection with interfaces
class OrderService {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly productRepository: ProductRepository,
    private readonly paymentProcessor: PaymentProcessor,
    private readonly emailService: EmailService,
    private readonly logger: Logger
  ) {}

  // Methods using injected dependencies...
}

// ✅ Factory for complex object creation
class OrderServiceFactory {
  static create(config: ServiceConfig): OrderService {
    const userRepo = new DatabaseUserRepository(config.database);
    const productRepo = new DatabaseProductRepository(config.database);
    const paymentProcessor = PaymentProcessorFactory.create(config.payment);
    const emailService = new SMTPEmailService(config.email);
    const logger = new FileLogger(config.logging.filename);

    return new OrderService(
      userRepo,
      productRepo,
      paymentProcessor,
      emailService,
      logger
    );
  }
}
```

## Conclusion

Software design principles are the foundation of creating maintainable, scalable, and robust software systems. By understanding and applying these principles, developers can:

1. **Create better software architecture** that stands the test of time
2. **Improve code maintainability** through clear separation of concerns
3. **Enhance team collaboration** with well-defined interfaces and responsibilities
4. **Reduce development costs** through code reuse and modularity
5. **Build more testable systems** through dependency injection and loose coupling

Remember that these principles are guidelines, not rigid rules. The key is to understand the underlying concepts and apply them judiciously based on your specific context and requirements. Start simple, and add complexity only when it's genuinely needed.

The journey to mastering software design is ongoing. As systems evolve and new challenges emerge, these fundamental principles provide a solid foundation for making good design decisions and creating software that developers will thank you for in the future.

<BackToTop />
