import BackToTop from "@/components/BackToTop";

# GraphQL Query Language

## Table of Contents

## Introduction

GraphQL is a query language for APIs that allows clients to request only the data they need. I### Variables

GraphQL supports variables, which allow you to parameterize your queries. This is useful for dynamic queries where the input values may change. Here's an example of a query with variables:

```graphql
query GetUser($id: ID!) {
  user(id: $id) {
    name
    email
  }
}
```

You can pass the variable `id` when executing the query, allowing you to reuse the same query structure with different values.

#### Using Variables in a Client Application

Here's how you would use variables in a client application using Apollo Client:

```javascript
import { useQuery, gql } from "@apollo/client";

const GET_USER = gql`
  query GetUser($id: ID!) {
    user(id: $id) {
      name
      email
      posts {
        title
      }
    }
  }
`;

function UserProfile({ userId }) {
  const { loading, error, data } = useQuery(GET_USER, {
    variables: { id: userId },
  });

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <h2>{data.user.name}</h2>
      <p>{data.user.email}</p>
      <h3>Posts</h3>
      <ul>
        {data.user.posts.map((post) => (
          <li key={post.title}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

#### Variables with Default Values

You can also define default values for variables:

```graphql
query GetPosts($status: String = "PUBLISHED", $limit: Int = 10) {
  posts(status: $status, limit: $limit) {
    id
    title
    publishedAt
  }
}
```

This query will fetch 10 published posts by default, but you can override these values when executing the query.

### Fragmentsby Facebook in 2012 and has since become a popular alternative to RESTful APIs. GraphQL provides a more flexible and efficient way to interact with APIs, enabling developers to define the structure of the response they want.

GraphQL is not a database query language but rather a specification for building APIs. It allows clients to specify the shape of the data they want, and the server responds with exactly that data. This eliminates over-fetching and under-fetching of data, making it more efficient than traditional REST APIs.

## Key Features

- **Declarative Data Fetching**: Clients can specify exactly what data they need, reducing the amount of data transferred over the network.
- **Single Endpoint**: GraphQL APIs typically expose a single endpoint, simplifying the API structure and reducing the number of requests needed to fetch related data.
- **Strongly Typed Schema**: GraphQL uses a schema to define the types of data available in the API, providing a clear contract between the client and server.
- **Real-time Capabilities**: GraphQL supports subscriptions, allowing clients to receive real-time updates when data changes on the server.

## Getting Started with GraphQL

To get started with GraphQL, you need to set up a GraphQL server. There are several libraries available for different programming languages that can help you build a GraphQL server, such as Apollo Server for Node.js, Graphene for Python, and GraphQL.js for JavaScript.
Once you have your server set up, you can define your GraphQL schema, which describes the types of data available in your API and the relationships between them. The schema is written in the GraphQL Schema Definition Language (SDL) and serves as a contract between the client and server.

### Example of Setting Up a Simple GraphQL Server with Apollo Server

Here's an example of setting up a basic GraphQL server using Apollo Server in Node.js:

```javascript
// Import required packages
const { ApolloServer } = require("apollo-server");

// Define your GraphQL schema
const typeDefs = `
  type User {
    id: ID!
    name: String!
    email: String!
  }
  
  type Query {
    users: [User]
    user(id: ID!): User
  }
  
  type Mutation {
    createUser(name: String!, email: String!): User
  }
`;

// Sample data
const users = [
  { id: "1", name: "John Doe", email: "john_doe@sample.com" },
  { id: "2", name: "Jane Smith", email: "jane_smith@sample.com" },
];

// Define resolvers
const resolvers = {
  Query: {
    users: () => users,
    user: (_, { id }) => users.find((user) => user.id === id),
  },
  Mutation: {
    createUser: (_, { name, email }) => {
      const newUser = {
        id: String(users.length + 1),
        name,
        email,
      };
      users.push(newUser);
      return newUser;
    },
  },
};

// Create Apollo Server instance
const server = new ApolloServer({ typeDefs, resolvers });

// Start the server
server.listen().then(({ url }) => {
  console.log(`ðŸš€ Server ready at ${url}`);
});
```

This example demonstrates a minimal GraphQL server that provides queries to fetch users and mutations to create new users.

## Basic Syntax

GraphQL queries are written in a syntax that resembles JSON. A query consists of fields that specify the data you want to retrieve. Hereâ€™s a simple example of a GraphQL query:

```graphql
query {
  user(id: "1") {
    name
    email
  }
}
```

This query requests the `name` and `email` fields of a user with the ID of "1". The server responds with a JSON object containing the requested data.

This query retrieves the `name` and `email` fields of a user with the ID of "1". The server responds with a JSON object containing only the requested fields, like this:

```json
{
  "data": {
    "user": {
      "name": "John Doe",
      "email": "john_doe@sample.com"
    }
  }
}
```

This response contains only the fields specified in the query, demonstrating GraphQL's ability to return exactly the data requested by the client.

<BackToTop />

### More Query Examples

Let's explore a few more query examples to better understand GraphQL's flexibility:

#### Querying Multiple Resources at Once

One of GraphQL's strengths is the ability to request multiple resources in a single query:

```graphql
query {
  user(id: "1") {
    name
    email
  }
  allPosts {
    title
    published
  }
}
```

This query requests both user information and a list of posts in a single request. The response would look like:

```json
{
  "data": {
    "user": {
      "name": "John Doe",
      "email": "john_doe@sample.com"
    },
    "allPosts": [
      { "title": "Introduction to GraphQL", "published": true },
      { "title": "Advanced GraphQL Techniques", "published": false }
    ]
  }
}
```

#### Querying Nested Data with Arguments

GraphQL allows you to pass arguments to any field to filter or customize results:

```graphql
query {
  user(id: "1") {
    name
    posts(status: "PUBLISHED", limit: 2) {
      title
      createdAt
    }
  }
}
```

This query requests a user and their 2 most recent published posts. The response might be:

```json
{
  "data": {
    "user": {
      "name": "John Doe",
      "posts": [
        {
          "title": "GraphQL Best Practices",
          "createdAt": "2025-05-15T12:00:00Z"
        },
        {
          "title": "Understanding REST vs GraphQL",
          "createdAt": "2025-04-10T09:30:00Z"
        }
      ]
    }
  }
}
```

<BackToTop />

## Queries

There are three main types of operations in GraphQL: queries, mutations, and subscriptions. Queries are used to fetch data from the server. They can be simple or complex, depending on the structure of the data you want to retrieve.

### Fields

In GraphQL, fields are the basic building blocks of queries. Each field corresponds to a specific piece of data in your schema. You can nest fields to retrieve related data. For example, if you have a `user` type with a `posts` field that returns a list of posts, you can query it like this:

```graphql
query {
  user(id: "1") {
    name
    posts {
      title
      content
    }
  }
}
```

This query retrieves the `name` of the user and the `title` and `content` of their posts. The server responds with a JSON object containing the requested data.

### Variables

GraphQL supports variables, which allow you to parameterize your queries. This is useful for dynamic queries where the input values may change. Hereâ€™s an example of a query with variables:

```graphql
query GetUser($id: ID!) {
  user(id: $id) {
    name
    email
  }
}
```

You can pass the variable `id` when executing the query, allowing you to reuse the same query structure with different values.

### Fragments

Fragments are reusable pieces of a query that can be shared across multiple queries. They help reduce duplication and make your queries more maintainable. Hereâ€™s an example of a fragment:

```graphql
fragment UserFields on User {
  name
  email
}
query {
  user(id: "1") {
    ...UserFields
  }
}
```

This query uses the `UserFields` fragment to retrieve the `name` and `email` fields of a user. Fragments can be defined once and reused in multiple queries, making your code cleaner and more efficient.

### Aliases

Aliases allow you to rename fields in your query, which is useful when you want to retrieve the same field multiple times with different parameters. Hereâ€™s an example of using aliases:

```graphql
query {
  user1: user(id: "1") {
    name
    email
  }
  user2: user(id: "2") {
    name
    email
  }
}
```

In this query, we retrieve the `name` and `email` of two different users, but we use aliases (`user1` and `user2`) to differentiate between them in the response. The server responds with a JSON object containing both users' data under their respective aliases.

### Directives

Directives are special instructions that can be added to fields in a query to modify their behavior. The most common directives are `@include` and `@skip`, which control whether a field should be included or skipped based on a condition. Hereâ€™s an example:

```graphql
query GetUser($includeEmail: Boolean!) {
  user(id: "1") {
    name
    email @include(if: $includeEmail)
  }
}
```

In this query, the `email` field will only be included in the response if the variable `includeEmail` is set to `true`. This allows you to conditionally include or exclude fields based on your requirements.

### Nested Queries

GraphQL allows you to nest queries to retrieve related data in a single request. This is particularly useful when dealing with complex data structures. For example, if you have a `user` type with a `posts` field that returns a list of posts, you can query it like this:

```graphql
query {
  user(id: "1") {
    name
    posts {
      title
      comments {
        content
      }
    }
  }
}
```

This query retrieves the `name` of the user, the `title` of their posts, and the `content` of the comments on those posts. The server responds with a JSON object containing all the requested data in a nested structure.

## Schema Definition

In GraphQL, the schema defines the types of data available in your API and the relationships between them. The schema is written in the GraphQL Schema Definition Language (SDL) and serves as a contract between the client and server. Hereâ€™s an example of a simple schema:

```graphql
type User {
  id: ID!
  name: String!
  email: String!
  posts: [Post!]!
}
type Post {
  id: ID!
  title: String!
  content: String!
}
```

This schema defines two types: `User` and `Post`. The `User` type has fields for `id`, `name`, `email`, and a list of `posts`. The `Post` type has fields for `id`, `title`, and `content`. The exclamation mark (`!`) indicates that the field is non-nullable, meaning it must always have a value.

<BackToTop />

## Mutations

Mutations are used to modify data on the server, such as creating, updating, or deleting records. They are similar to queries but are designed for operations that change the state of the data.

### Creating a Mutation

To create a mutation, you define a mutation type in your schema. Hereâ€™s an example of a mutation to create a new user:

```graphql
type Mutation {
  createUser(name: String!, email: String!): User!
}
```

This mutation takes `name` and `email` as input parameters and returns the newly created `User` object. The exclamation mark (`!`) indicates that the mutation will always return a `User` object.

### Executing a Mutation

To execute a mutation, you use the `mutation` keyword followed by the mutation name and the input parameters. Hereâ€™s an example of executing the `createUser` mutation:

```graphql
mutation {
  createUser(name: "Jane Doe", email: "jane_doe@sample.com") {
    id
    name
    email
  }
}
```

This mutation creates a new user with the specified `name` and `email`, and it returns the `id`, `name`, and `email` of the newly created user. The server responds with a JSON object containing the created user's data.

### Updating a Mutation

To update an existing record, you can define a mutation that takes the record's ID and the fields to be updated. Hereâ€™s an example of an update mutation for a user:

```graphql
type Mutation {
  updateUser(id: ID!, name: String, email: String): User!
}
```

This mutation takes the `id` of the user to be updated and optional `name` and `email` fields. It returns the updated `User` object.

### Executing an Update Mutation

To execute the update mutation, you can use the following syntax:

```graphql
mutation {
  updateUser(id: "1", name: "John Smith") {
    id
    name
    email
  }
}
```

This mutation updates the user with ID "1" to have the new name "John Smith". It returns the `id`, `name`, and `email` of the updated user. The server responds with a JSON object containing the updated user's data.

### Deleting a Mutation

To delete a record, you can define a mutation that takes the record's ID as input. Hereâ€™s an example of a delete mutation for a user:

```graphql
type Mutation {
  deleteUser(id: ID!): User!
}
```

This mutation takes the `id` of the user to be deleted and returns the deleted `User` object. The exclamation mark (`!`) indicates that the mutation will always return a `User` object, even if it is deleted.

### Executing a Delete Mutation

To execute the delete mutation, you can use the following syntax:

```graphql
mutation {
  deleteUser(id: "1") {
    id
    name
    email
  }
}
```

This mutation deletes the user with ID "1" and returns the `id`, `name`, and `email` of the deleted user. The server responds with a JSON object containing the deleted user's data.

<BackToTop />

### Multiple Mutations

GraphQL allows you to execute multiple mutations in a single request. This is useful when you need to perform several related operations at once. You can group multiple mutations within a single `mutation` block. Hereâ€™s an example:

```graphql
mutation {
  createUser(name: "Alice", email: "alice_d@sample.com") {
    id
    name
    email
  }
  updateUser(id: "2", name: "Bob Smith") {
    id
    name
    email
  }
  deleteUser(id: "3") {
    id
    name
    email
  }
}
```

This mutation creates a new user, updates an existing user, and deletes another user in a single request. The server responds with a JSON object containing the results of all three operations.

### Mutations with Input Types

For complex mutations with many input fields, it's common to use input types to organize the parameters:

```graphql
# Schema definition
type Mutation {
  createPost(input: PostInput!): Post!
}

input PostInput {
  title: String!
  content: String!
  authorId: ID!
  tags: [String]
  published: Boolean = false
}

# Mutation execution
mutation {
  createPost(
    input: {
      title: "GraphQL Mutations Explained"
      content: "This is a detailed post about GraphQL mutations..."
      authorId: "1"
      tags: ["GraphQL", "API", "Tutorial"]
      published: true
    }
  ) {
    id
    title
    author {
      name
    }
  }
}
```

This approach makes mutations more maintainable and easier to extend when you need to add new fields.

<BackToTop />

### File Upload Mutations

GraphQL can also handle file uploads with the right server setup (like apollo-server-express with graphql-upload):

```graphql
# Schema
type Mutation {
  uploadProfilePicture(userId: ID!, file: Upload!): User!
}

# Client code (using Apollo Client)
import { useMutation, gql } from '@apollo/client';

const UPLOAD_FILE = gql`
  mutation UploadFile($userId: ID!, $file: Upload!) {
    uploadProfilePicture(userId: $userId, file: $file) {
      id
      name
      profilePictureUrl
    }
  }
`;

function ProfileUploader() {
  const [uploadFile] = useMutation(UPLOAD_FILE);

  const handleFileChange = (e) => {
    const file = e.target.files[0];
    uploadFile({ variables: { userId: "1", file } });
  };

  return <input type="file" onChange={handleFileChange} />;
}
```

<BackToTop />

## Subscriptions

Subscriptions allow clients to receive real-time updates from the server when data changes. This is useful for applications that require live updates, such as chat applications or collaborative tools. Subscriptions are defined in the schema and can be executed using the `subscription` keyword. Hereâ€™s an example of a subscription to receive updates when a new user is created:

```graphql
type Subscription {
  userCreated: User!
}
```

This subscription listens for events when a new user is created and returns the newly created `User` object.

### Executing a Subscription

To execute a subscription, you can use the following syntax:

```graphql
subscription {
  userCreated {
    id
    name
    email
  }
}
```

This subscription listens for the `userCreated` event and returns the `id`, `name`, and `email` of the newly created user. When a new user is created on the server, the client will receive real-time updates with the user's data.

<BackToTop />

### Filtered Subscriptions

You can also filter subscriptions to only receive updates for specific events. Here's an example of a subscription that only listens for posts created by a specific user:

```graphql
# Schema
type Subscription {
  postCreated(authorId: ID): Post!
}

# Subscription
subscription {
  postCreated(authorId: "1") {
    id
    title
    content
    author {
      name
    }
  }
}
```

<BackToTop />

### Implementing Subscriptions with Apollo Server

Here's a simple example of how to implement subscriptions using Apollo Server:

```javascript
const { ApolloServer, PubSub } = require("apollo-server");

// Create a PubSub instance
const pubsub = new PubSub();
const POST_CREATED = "POST_CREATED";

// Define your schema
const typeDefs = `
  type Post {
    id: ID!
    title: String!
    content: String!
    author: User!
  }
  
  type User {
    id: ID!
    name: String!
  }
  
  type Query {
    posts: [Post]
  }
  
  type Mutation {
    createPost(title: String!, content: String!, authorId: ID!): Post
  }
  
  type Subscription {
    postCreated(authorId: ID): Post
  }
`;

// Sample data
const users = [
  { id: "1", name: "John Doe" },
  { id: "2", name: "Jane Smith" },
];

const posts = [];

// Define resolvers
const resolvers = {
  Query: {
    posts: () => posts,
  },
  Mutation: {
    createPost: (_, { title, content, authorId }) => {
      const post = {
        id: String(posts.length + 1),
        title,
        content,
        author: users.find((user) => user.id === authorId),
      };
      posts.push(post);

      // Publish the event
      pubsub.publish(POST_CREATED, { postCreated: post });

      return post;
    },
  },
  Subscription: {
    postCreated: {
      subscribe: (_, { authorId }) => {
        return pubsub.asyncIterator([POST_CREATED]);
      },
      resolve: (payload, { authorId }) => {
        // Filter subscriptions if authorId is provided
        if (authorId && payload.postCreated.author.id !== authorId) {
          return null;
        }
        return payload.postCreated;
      },
    },
  },
};

// Create the server
const server = new ApolloServer({
  typeDefs,
  resolvers,
});

// Start the server
server.listen().then(({ url, subscriptionsUrl }) => {
  console.log(`ðŸš€ Server ready at ${url}`);
  console.log(`ðŸš€ Subscriptions ready at ${subscriptionsUrl}`);
});
```

<BackToTop />

## Validations

GraphQL provides built-in validation mechanisms to ensure that queries and mutations conform to the schema. When a query is executed, the server checks if the requested fields exist in the schema and if the input parameters are of the correct type. If any validation errors occur, the server responds with an error message indicating the issue.

### Common Validation Errors

- **Field Not Found**: If a requested field does not exist in the schema, the server returns an error indicating that the field is not found.
- **Invalid Input Type**: If the input parameters do not match the expected types defined in the schema, the server returns an error indicating the type mismatch.
- **Required Fields Missing**: If a required field is missing in a mutation, the server returns an error indicating that the required field is not provided.
- **Unauthorized Access**: If a user tries to access a field or perform an operation they are not authorized for, the server returns an error indicating insufficient permissions.

## Error Handling

GraphQL provides a standardized way to handle errors in queries and mutations. When an error occurs, the server responds with an error object that contains information about the error, including a message and optional details. Hereâ€™s an example of an error response:

```json
{
  "errors": [
    {
      "message": "Field 'email' is not defined in type 'User'",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ]
    }
  ],
  "data": null
}
```

This response indicates that the requested field `email` is not defined in the `User` type. The `locations` field provides information about where the error occurred in the query.

<BackToTop />

### Custom Error Handling in GraphQL

GraphQL servers can provide custom error handling to make debugging easier and provide more context to clients. Here's an example of a resolver with custom error handling:

```javascript
const resolvers = {
  Query: {
    user: (parent, { id }, context, info) => {
      try {
        // Check if user is authenticated
        if (!context.isAuthenticated) {
          throw new AuthenticationError(
            "You must be logged in to view user data"
          );
        }

        // Check if user has permission to access this data
        if (!context.hasPermission("READ_USER")) {
          throw new ForbiddenError(
            "You do not have permission to view this user data"
          );
        }

        const user = getUserById(id);

        if (!user) {
          throw new UserInputError("User not found", {
            invalidArgs: ["id"],
          });
        }

        return user;
      } catch (error) {
        // Log the error for internal tracking
        console.error(`Error fetching user ${id}:`, error);

        // Re-throw Apollo errors, wrap other errors
        if (error instanceof ApolloError) {
          throw error;
        } else {
          throw new ApolloError(
            "An unexpected error occurred",
            "INTERNAL_SERVER_ERROR",
            {
              originalError: error,
            }
          );
        }
      }
    },
  },
};
```

<BackToTop />

### Handling Errors on the Client Side

Here's an example of how to handle errors on the client side using Apollo Client:

```javascript
import { useQuery, gql } from "@apollo/client";

const GET_USER = gql`
  query GetUser($id: ID!) {
    user(id: $id) {
      id
      name
      profilePicture
    }
  }
`;

function UserProfile({ userId }) {
  const { loading, error, data } = useQuery(GET_USER, {
    variables: { id: userId },
    onError: (error) => {
      // Log the error to a monitoring service
      logErrorToService(error);
    },
  });

  if (loading) return <p>Loading...</p>;

  if (error) {
    // Check for specific error types
    if (error.graphQLErrors) {
      return error.graphQLErrors.map(({ message, extensions }, i) => {
        if (extensions?.code === "UNAUTHENTICATED") {
          // Redirect to login page
          return <p key={i}>Please log in to view this content</p>;
        } else if (extensions?.code === "FORBIDDEN") {
          return <p key={i}>You don't have permission to view this content</p>;
        } else {
          return <p key={i}>Error: {message}</p>;
        }
      });
    }

    if (error.networkError) {
      return <p>Network error: Please check your connection</p>;
    }

    return <p>An unexpected error occurred</p>;
  }

  return (
    <div>
      <h1>{data.user.name}</h1>
      <img src={data.user.profilePicture} alt={`${data.user.name}'s profile`} />
    </div>
  );
}
```

## Best Practices

When working with GraphQL, there are several best practices to follow to ensure your queries and mutations are efficient and maintainable:

- **Use Fragments**: Fragments help reduce duplication in queries and make your code more maintainable. Define reusable fragments for common fields and use them across multiple queries.
- **Use Aliases**: Aliases allow you to retrieve the same field multiple times with different parameters. This is useful when you need to fetch related data in a single query.
- **Use Variables**: Variables allow you to parameterize your queries, making them more dynamic and reusable. Use variables for input parameters in queries and mutations.
- **Optimize Queries**: Avoid over-fetching and under-fetching data by carefully designing your queries. Only request the fields you need to minimize the amount of data transferred over the network.
- **Use Directives**: Directives allow you to conditionally include or exclude fields based on certain conditions. Use directives like `@include` and `@skip` to control the behavior of your queries.

## Conclusion

GraphQL is a powerful query language for APIs that provides a flexible and efficient way to interact with data. It allows clients to specify exactly what data they need, reducing over-fetching and under-fetching of data. With its declarative syntax, strong typing, and real-time capabilities, GraphQL has become a popular choice for building modern APIs.

## Further Reading

- [GraphQL Official Documentation](https://graphql.org/learn/)
- [GraphQL Best Practices](https://graphql.org/learn/best-practices/)

<BackToTop />
