import BackToTop from "@/components/BackToTop";

# Consistency Models

## Table of Contents

## Overview

Consistency models define the guarantees provided by a database system regarding the visibility of changes made by transactions. They are crucial for ensuring that all users see a consistent view of the data, especially in distributed systems. They help manage how and when changes made by one transaction become visible to others, which is essential for maintaining data integrity and correctness in applications. Different consistency models offer varying trade-offs between performance, availability, and the strictness of consistency.

## Key Concepts

- **Consistency**: Ensures that a database remains in a valid state after transactions, adhering to predefined rules and constraints.
- **Visibility**: Refers to when changes made by one transaction become visible to others.
- **Trade-offs**: Different models balance consistency, availability, and performance in various ways.

## Types of Consistency Models

- **Strong Consistency**: Guarantees that all transactions see the same data at the same time, ensuring immediate visibility of changes.
- **Weak Consistency**: Allows for temporary inconsistencies, where changes may not be immediately visible to all transactions, but will eventually become consistent.
- **Eventual Consistency**: A form of weak consistency where the system guarantees that if no new updates are made, eventually all accesses will return the last updated value. This model is often used in distributed systems to improve availability and performance.

## Common Consistency Models

- **Linearizability**: A strong consistency model that ensures operations appear to occur instantaneously at some point between their start and end times.
- **Sequential Consistency**: Ensures that the result of execution is the same as if all operations were executed in some sequential order, but does not require that this order be the same for all users.
- **Causal Consistency**: Ensures that operations that are causally related are seen by all users in the same order, while allowing concurrent operations to be seen in different orders by different users.
- **Read Your Writes**: Guarantees that a transaction will always see its own writes, ensuring that once a transaction has written data, it can read that data in subsequent operations.
- **Monotonic Reads**: Ensures that if a transaction reads a value, any subsequent reads will return that value or a more recent one, preventing "stale" reads.
- **Monotonic Writes**: Guarantees that writes by a transaction will be seen in the order they were issued, preventing out-of-order writes.

### Linearizability

Linearizability is a strong consistency model that provides the illusion that all operations on a data structure occur instantaneously at some point between their start and end times. This means that once a write operation completes, all subsequent read operations will see that write, ensuring a consistent view of the data across all transactions.

#### Example 1: Bank Transfer

```sql title="Linearizability in a Distributed System"
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
COMMIT TRANSACTION;
```

In this example, once the transaction is committed, any subsequent read operation on either account will reflect the updated balances, ensuring that all users see a consistent view of the data.

#### Example 2: Inventory Management

```sql title="Linearizable Inventory Update"
-- Transaction A
BEGIN TRANSACTION;
UPDATE inventory SET quantity = quantity - 5 WHERE product_id = 101;
COMMIT TRANSACTION;

-- Transaction B (starts after A commits)
BEGIN TRANSACTION;
SELECT quantity FROM inventory WHERE product_id = 101; -- Will see updated quantity
COMMIT TRANSACTION;
```

With linearizability, Transaction B is guaranteed to see the updated inventory quantity from Transaction A, preventing overselling scenarios.

#### Example 3: User Authentication

```sql title="Linearizable User Status Update"
-- Admin updates user status
BEGIN TRANSACTION;
UPDATE users SET status = 'suspended' WHERE user_id = 12345;
COMMIT TRANSACTION;

-- User attempts login immediately after
BEGIN TRANSACTION;
SELECT status FROM users WHERE user_id = 12345; -- Always sees 'suspended'
COMMIT TRANSACTION;
```

This ensures that security updates are immediately visible to all parts of the system.

### Sequential Consistency

Sequential consistency is a consistency model that ensures the result of execution is the same as if all operations were executed in some sequential order. However, this model does not require that this order be the same for all users. It allows for concurrent operations to be seen in different orders by different users, as long as the overall result is consistent with some sequential order.

#### Example 1: Distributed Account Updates

```sql title="Sequential Consistency in a Distributed System"
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 50 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 50 WHERE account_id = 2;
COMMIT TRANSACTION;
```

In this example, the updates to the accounts can be seen in different orders by different users, but the overall effect is that the total balance remains consistent. If one user sees the first update before the second, another user might see the second update before the first, but both will agree on the final balances after the transaction is committed.

#### Example 2: Multi-Region Content Updates

```sql title="Sequential Consistency in Content Management"
-- Content creator updates article
BEGIN TRANSACTION;
UPDATE articles SET title = 'New Title' WHERE article_id = 123;
UPDATE articles SET content = 'Updated content...' WHERE article_id = 123;
COMMIT TRANSACTION;
```

Different regions might see these updates in different orders, but eventually all regions will have the same final state.

#### Example 3: Shopping Cart Operations

```sql title="Sequential Consistency in E-commerce"
-- User A adds items to cart
BEGIN TRANSACTION;
INSERT INTO cart_items (user_id, product_id, quantity) VALUES (1, 101, 2);
INSERT INTO cart_items (user_id, product_id, quantity) VALUES (1, 102, 1);
COMMIT TRANSACTION;
```

Different database replicas might process these insertions in different orders, but the final cart state will be consistent across all replicas.

### Causal Consistency

Causal consistency is a consistency model that ensures operations that are causally related are seen by all users in the same order, while allowing concurrent operations to be seen in different orders by different users.
This model is particularly useful in distributed systems where operations may occur independently but still have causal relationships.

#### Example 1: Message Thread

```sql title="Causal Consistency in a Distributed System"
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 30 WHERE account_id = 1; -- Operation A
UPDATE accounts SET balance = balance + 30 WHERE account_id = 2; -- Operation B
COMMIT TRANSACTION;
```

In this example, if Operation A causally precedes Operation B, all users will see Operation A before Operation B. However, if there are concurrent operations that do not have a causal relationship, different users may see these operations in different orders. For instance, one user might see Operation A before Operation B, while another user might see Operation B before Operation A, as long as the causal relationship is maintained.

#### Example 2: Social Media Posts and Comments

```sql title="Causal Consistency in Social Media"
-- User creates a post (Operation A)
BEGIN TRANSACTION;
INSERT INTO posts (user_id, content, timestamp) VALUES (1, 'Hello World!', NOW());
COMMIT TRANSACTION;

-- User comments on their own post (Operation B - causally depends on A)
BEGIN TRANSACTION;
INSERT INTO comments (post_id, user_id, content, timestamp)
VALUES (LAST_INSERT_ID(), 1, 'Adding more context', NOW());
COMMIT TRANSACTION;
```

All users will see the post before the comment, maintaining causal order.

#### Example 3: Order Processing Workflow

```sql title="Causal Consistency in Order Processing"
-- Order placement (Operation A)
BEGIN TRANSACTION;
INSERT INTO orders (customer_id, total_amount, status) VALUES (123, 99.99, 'pending');
COMMIT TRANSACTION;

-- Payment processing (Operation B - depends on A)
BEGIN TRANSACTION;
UPDATE orders SET status = 'paid' WHERE order_id = LAST_INSERT_ID();
INSERT INTO payments (order_id, amount, method) VALUES (LAST_INSERT_ID(), 99.99, 'credit_card');
COMMIT TRANSACTION;

-- Shipping (Operation C - depends on B)
BEGIN TRANSACTION;
UPDATE orders SET status = 'shipped' WHERE order_id = ?;
INSERT INTO shipments (order_id, tracking_number) VALUES (?, 'TRACK123');
COMMIT TRANSACTION;
```

The causal chain (order → payment → shipping) is preserved for all users.

### Read Your Writes

Read Your Writes is a consistency model that guarantees that a transaction will always see its own writes. This means that once a transaction has written data, it can read that data in subsequent operations, ensuring that the transaction has a consistent view of its own changes.

#### Example 1: Account Balance Update

```sql title="Read Your Writes in a Transaction"
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 20 WHERE account_id = 1; -- Write Operation
SELECT balance FROM accounts WHERE account_id = 1; -- Read Operation
COMMIT TRANSACTION;
```

In this example, after the write operation that updates the balance of account 1, the subsequent read operation will always return the updated balance. This ensures that the transaction has a consistent view of its own changes, preventing scenarios where a transaction reads stale data that it has just written.

#### Example 2: User Profile Update

```sql title="Read Your Writes for Profile Management"
BEGIN TRANSACTION;
UPDATE user_profiles SET email = 'newemail@example.com' WHERE user_id = 456; -- Write
UPDATE user_profiles SET last_modified = NOW() WHERE user_id = 456; -- Write
SELECT email, last_modified FROM user_profiles WHERE user_id = 456; -- Read
COMMIT TRANSACTION;
```

The user will immediately see their updated email and timestamp within the same transaction.

#### Example 3: Shopping Cart Management

```sql title="Read Your Writes in Shopping Cart"
BEGIN TRANSACTION;
INSERT INTO cart_items (user_id, product_id, quantity, price) VALUES (789, 101, 2, 29.99);
UPDATE cart_totals SET total_amount = total_amount + 59.98 WHERE user_id = 789;
SELECT total_amount FROM cart_totals WHERE user_id = 789; -- Sees updated total
COMMIT TRANSACTION;
```

The user's session will immediately reflect the updated cart total after adding items.

#### Example 4: Document Editing

```sql title="Read Your Writes in Document Collaboration"
BEGIN TRANSACTION;
UPDATE documents SET content = 'Updated document content...' WHERE doc_id = 'doc123';
UPDATE documents SET version = version + 1 WHERE doc_id = 'doc123';
SELECT content, version FROM documents WHERE doc_id = 'doc123'; -- Sees latest changes
COMMIT TRANSACTION;
```

The editor immediately sees their own changes and the incremented version number.

### Monotonic Reads

Monotonic Reads is a consistency model that ensures if a transaction reads a value, any subsequent reads will return that value or a more recent one. This prevents "stale" reads, where a transaction might read an older version of the data after having read a newer version.

#### Example 1: Account Balance Monitoring

```sql title="Monotonic Reads in a Transaction"
BEGIN TRANSACTION;
SELECT balance FROM accounts WHERE account_id = 1; -- Initial Read: $1000
UPDATE accounts SET balance = balance + 10 WHERE account_id = 1; -- Update Operation
SELECT balance FROM accounts WHERE account_id = 1; -- Subsequent Read: $1010 (or newer)
COMMIT TRANSACTION;
```

In this example, the first read operation retrieves the initial balance of account 1. After the update operation, the subsequent read operation will either return the same balance or a more recent one, ensuring that the transaction does not read stale data. This guarantees that once a transaction has read a value, any future reads will not return an older version of that value, maintaining a consistent view of the data.

#### Example 2: Cache Consistency

```sql title="Monotonic Reads in Caching System"
-- Application reads user preferences
BEGIN TRANSACTION;
SELECT theme, language FROM user_preferences WHERE user_id = 123; -- Read: theme='dark', language='en'
-- ... other operations ...
SELECT theme, language FROM user_preferences WHERE user_id = 123; -- Must return same or newer values
COMMIT TRANSACTION;
```

The second read will never return older preference values, ensuring consistent user experience.

#### Example 3: Audit Log Reading

```sql title="Monotonic Reads in Audit Logs"
BEGIN TRANSACTION;
SELECT COUNT(*) FROM audit_logs WHERE user_id = 456; -- Initial count: 50
-- Other transactions may add audit entries
SELECT COUNT(*) FROM audit_logs WHERE user_id = 456; -- Count: 50 or higher, never less
COMMIT TRANSACTION;
```

The audit log count can only increase or stay the same, never decrease within the session.

#### Example 4: News Feed Timeline

```sql title="Monotonic Reads in Social Media"
BEGIN TRANSACTION;
SELECT post_id, timestamp FROM news_feed WHERE user_id = 789 ORDER BY timestamp DESC LIMIT 10;
-- User scrolls down or refreshes
SELECT post_id, timestamp FROM news_feed WHERE user_id = 789 ORDER BY timestamp DESC LIMIT 10;
-- Will not show older posts that weren't in the first read
COMMIT TRANSACTION;
```

Users won't see their timeline "go backwards" in time during a session.

### Monotonic Writes

Monotonic Writes is a consistency model that guarantees that writes by a transaction will be seen in the order they were issued. This prevents out-of-order writes, ensuring that if a transaction issues multiple writes, they will be applied in the same order to all users.

#### Example 1: Account Transfer

```sql title="Monotonic Writes in a Transaction"
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 10 WHERE account_id = 1; -- First Write
UPDATE accounts SET balance = balance + 10 WHERE account_id = 2; -- Second Write
COMMIT TRANSACTION;
```

In this example, the first write operation updates the balance of account 1, and the second write operation updates the balance of account 2. The monotonic writes model ensures that all users will see these writes in the same order: first the update to account 1, then the update to account 2. This prevents scenarios where one user might see the second write before the first, maintaining a consistent order of operations across all users.

#### Example 2: Order Status Progression

```sql title="Monotonic Writes in Order Processing"
BEGIN TRANSACTION;
UPDATE orders SET status = 'processing' WHERE order_id = 12345; -- First Write
UPDATE orders SET status = 'shipped' WHERE order_id = 12345; -- Second Write
UPDATE orders SET status = 'delivered' WHERE order_id = 12345; -- Third Write
COMMIT TRANSACTION;
```

All users will observe the order status progression in the correct sequence: processing → shipped → delivered.

#### Example 3: User Permission Updates

```sql title="Monotonic Writes in Security Management"
BEGIN TRANSACTION;
UPDATE user_permissions SET role = 'user' WHERE user_id = 999; -- First Write: demote
UPDATE user_permissions SET can_delete = false WHERE user_id = 999; -- Second Write: remove delete permission
UPDATE user_permissions SET last_modified = NOW() WHERE user_id = 999; -- Third Write: timestamp
COMMIT TRANSACTION;
```

Security changes are applied in order, ensuring proper permission management sequence.

#### Example 4: Inventory Management

```sql title="Monotonic Writes in Inventory System"
BEGIN TRANSACTION;
UPDATE inventory SET reserved_quantity = reserved_quantity + 5 WHERE product_id = 101; -- First Write
UPDATE inventory SET available_quantity = available_quantity - 5 WHERE product_id = 101; -- Second Write
UPDATE inventory SET last_updated = NOW() WHERE product_id = 101; -- Third Write
COMMIT TRANSACTION;
```

Inventory updates maintain proper sequence: reserve → reduce available → timestamp.

#### Example 5: File System Operations

```sql title="Monotonic Writes in File Management"
BEGIN TRANSACTION;
UPDATE files SET size = 1024000 WHERE file_id = 'file123'; -- First Write: update size
UPDATE files SET checksum = 'abc123def456' WHERE file_id = 'file123'; -- Second Write: update checksum
UPDATE files SET modified_date = NOW() WHERE file_id = 'file123'; -- Third Write: update timestamp
COMMIT TRANSACTION;
```

File metadata updates occur in the correct order, maintaining data integrity.

## Practical Implications

- **Application Design**: Understanding consistency models helps developers design applications that can handle data correctly under different conditions, especially in distributed systems.
- **Performance Considerations**: Different models can impact the performance of applications, as stronger consistency models often require more coordination and can lead to increased latency.
- **Trade-offs**: Choosing the right consistency model involves trade-offs between consistency, availability, and performance, depending on the specific requirements of the application.

### Application

```sql title="Example of Consistency Model in a Distributed System"
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 50 WHERE account_id = 1; -- Write Operation
UPDATE accounts SET balance = balance + 50 WHERE account_id = 2; -- Write Operation
SELECT balance FROM accounts WHERE account_id = 1; -- Read Operation
SELECT balance FROM accounts WHERE account_id = 2; -- Read Operation
COMMIT TRANSACTION;
```

In this example, the transaction updates the balances of two accounts and then reads their values. Depending on the consistency model in use, the visibility of these changes may vary. For instance, if using linearizability, all users will see the updated balances immediately after the transaction commits. In contrast, if using eventual consistency, some users may see the old balances until the system converges to a consistent state.

## Choosing a Consistency Model

When selecting a consistency model, consider the following factors:

- **Application Requirements**: Determine the level of consistency needed for your application. For example, financial applications may require strong consistency, while social media applications may tolerate eventual consistency.
- **Performance Needs**: Assess the performance implications of different models. Strong consistency models may introduce latency due to the need for coordination, while weaker models may allow for higher throughput and lower latency.
- **Data Distribution**: In distributed systems, consider how data is partitioned and replicated.
- **User Experience**: Understand how different consistency models affect user experience, especially in applications where users expect real-time updates or immediate feedback on their actions.

## Next Steps

### Immediate Actions

| Priority   | Action                                                                  | Purpose                                                |
| ---------- | ----------------------------------------------------------------------- | ------------------------------------------------------ |
| **High**   | [Transaction Management](/db-transaction-models/transaction-management) | Master transaction handling within ORM frameworks      |
| **High**   | [Concurrency Control](/db-transaction-models/concurrency-control)       | Prevent data conflicts in multi-user ORM applications  |
| **Medium** | [Storage Systems](/db-data-storage/storage-systems)                     | Understand how data is physically stored and retrieved |

### Optional Actions

| Action                                                                                                                             | Purpose                                                        |
| ---------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| [Development Resources and Tools for Back-End Development](/util-general-development-resources-and-tools-for-back-end-development) | Explore essential tools and frameworks for backend development |

<BackToTop />
