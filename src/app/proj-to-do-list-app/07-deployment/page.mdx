# Deployment

## Introduction

In this final module, we'll prepare our To-Do List application for production and deploy it to a hosting platform. Deploying a full-stack application involves several steps, including setting up the production environment, building the application, and configuring the hosting services.

## Preparing for Production

Before deploying, we need to make some adjustments to our application to ensure it's ready for production.

### Environment Variables

Ensure all sensitive information is stored in environment variables:

1. Create a `.env.local` file for Next.js frontend (never commit this to version control):

```
NEXT_PUBLIC_API_URL=https://your-api-domain.com/api
```

2. Create a `.env` file for the Express backend (never commit this to version control):

```dotenv title=".env"
# Environment variables for the Express backend
PORT=3001
NODE_ENV=production
DB_HOST=your-db-host
DB_USER=your-db-user
DB_PASS=your-db-password
DB_NAME=todo_app_db
SESSION_SECRET=your-session-secret
CLIENT_URL=https://your-frontend-domain.com
```

### Build Process

Next.js applications need to be built before deployment. This process compiles the application and optimizes it for production.
Set up scripts in `package.json` for building the application:

```json title="package.json"
"scripts": {
  "build": "next build",
  "start": "next start",
  "build:server": "tsc -p tsconfig.server.json",
  "start:server": "node dist/server/index.js"
}
```

Create a `tsconfig.server.json` file for the backend:

```json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "dist",
    "target": "es2019",
    "isolatedModules": false,
    "noEmit": false
  },
  "include": ["src/server/**/*.ts", "src/models/**/*.ts"]
}
```

## Deployment Options

There are several ways to deploy our full-stack application. We'll cover two common approaches:

1. **Separate Deployment**: Deploy the frontend and backend separately
2. **Unified Deployment**: Deploy both frontend and backend together

### Option 1: Separate Deployment

#### Frontend Deployment (Next.js)

The Next.js frontend can be deployed to platforms like Vercel, Netlify, or AWS Amplify.

**Deploying to Vercel**:

1. Create an account on [Vercel](https://vercel.com)
2. Install the Vercel CLI:

```bash
npm install -g vercel
```

3. Deploy the application:

```bash
vercel
```

Or connect your GitHub repository to Vercel for automatic deployments.

**Environment Variables on Vercel**:

1. Go to your project settings on Vercel
2. Add the environment variables from your `.env.local` file

#### Backend Deployment (Express)

The Express backend can be deployed to platforms like Heroku, DigitalOcean, or AWS.

**Deploying to Heroku**:

1. Create an account on [Heroku](https://heroku.com)
2. Install the Heroku CLI:

```bash
npm install -g heroku
```

3. Create a `Procfile` in the root directory:

```
web: node dist/server/index.js
```

4. Initialize a Git repository (if not already done):

```bash
git init
git add .
git commit -m "Initial commit"
```

5. Create a Heroku app and deploy:

```bash
heroku create your-app-name
git push heroku master
```

**Environment Variables on Heroku**:

```bash
heroku config:set DB_HOST=your-db-host
heroku config:set DB_USER=your-db-user
heroku config:set DB_PASS=your-db-password
heroku config:set DB_NAME=todo_app_db
heroku config:set SESSION_SECRET=your-session-secret
heroku config:set CLIENT_URL=https://your-frontend-domain.com
```

#### Database Deployment

For the MySQL database, you can use managed database services like:

- Amazon RDS
- DigitalOcean Managed Databases
- PlanetScale
- Railway

Steps for setting up a MySQL database on Amazon RDS:

1. Sign in to the AWS Management Console
2. Go to the RDS service
3. Click "Create database"
4. Select MySQL as the database engine
5. Configure the database settings
6. Create the database
7. Note the endpoint, username, and password
8. Update your environment variables with the database connection details

### Option 2: Unified Deployment

For a unified deployment, you can use platforms like:

- Railway
- Render
- AWS Elastic Beanstalk

**Deploying to Railway**:

1. Create an account on [Railway](https://railway.app)
2. Install the Railway CLI:

```bash
npm install -g @railway/cli
```

3. Initialize and deploy your project:

```bash
railway login
railway init
railway up
```

4. Add a MySQL database service in the Railway dashboard
5. Configure environment variables in the Railway dashboard

## CORS Configuration for Production

Update your CORS configuration in the backend for production:

```typescript
// In src/server/index.ts

app.use(
  cors({
    origin: process.env.CLIENT_URL || "http://localhost:3000",
    credentials: true,
  })
);
```

## Security Best Practices for Production

1. **HTTPS**: Ensure your application uses HTTPS
2. **HTTP Headers**: Set security headers
3. **Rate Limiting**: Implement rate limiting for API endpoints
4. **Input Validation**: Validate all user inputs
5. **Database Security**: Use parameterized queries
6. **Error Handling**: Don't expose sensitive information in error messages

Add a middleware for security headers:

```typescript
// In src/server/index.ts

import helmet from "helmet";

// ...

// Security headers
app.use(helmet());
```

Install Helmet:

```bash
npm install helmet
```

## Monitoring and Analytics

Consider adding monitoring and analytics to your production application:

1. **Error Tracking**: Use services like Sentry or Bugsnag
2. **Performance Monitoring**: Use services like New Relic or DataDog
3. **Usage Analytics**: Use services like Google Analytics or Mixpanel

Example of adding Sentry to your application:

```bash
npm install @sentry/node @sentry/nextjs
```

Configure Sentry for the backend:

```typescript
// In src/server/index.ts

import * as Sentry from "@sentry/node";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
});

app.use(Sentry.Handlers.requestHandler());

// ... your routes

app.use(Sentry.Handlers.errorHandler());
```

## Continuous Integration/Continuous Deployment (CI/CD)

Set up CI/CD for automatic testing and deployment:

1. **GitHub Actions**: For GitHub repositories
2. **GitLab CI/CD**: For GitLab repositories
3. **Jenkins**: Self-hosted CI/CD

Example GitHub Actions workflow (`.github/workflows/ci.yml`):

```yaml
name: CI/CD

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: "16"
      - name: Install dependencies
        run: npm ci
      - name: Run tests
        run: npm test

  deploy:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: "16"
      - name: Install dependencies
        run: npm ci
      - name: Build
        run: npm run build
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: "--prod"
```

## Maintenance and Updates

After deployment, it's important to maintain your application:

1. **Regular Updates**: Keep dependencies up to date
2. **Security Patches**: Apply security patches promptly
3. **Backup Strategy**: Implement regular database backups
4. **Monitoring**: Monitor application performance and errors
5. **Feature Updates**: Plan and implement new features

## Conclusion

Congratulations! You've completed the full-stack To-Do List application project. Throughout this project, you've learned:

1. Setting up a Next.js project with TypeScript and Tailwind CSS
2. Creating and connecting to a MySQL database
3. Implementing a REST API with Express
4. Using Sequelize ORM for database operations
5. Building a responsive user interface
6. Implementing user authentication with Passport.js and bcrypt
7. Testing and debugging your application
8. Deploying your application to production

This project has covered all the essential aspects of full-stack web development. You can now use these skills to build more complex applications or extend this To-Do List application with additional features.

## Further Improvements

Here are some ideas for further improving your To-Do List application:

1. Add task categories or tags
2. Implement task priorities
3. Add due date notifications
4. Create shared task lists for teams
5. Add file attachments to tasks
6. Implement a mobile app using React Native
7. Add a dark mode theme
8. Implement task search and filtering
9. Add keyboard shortcuts for power users
10. Create a public API for third-party integrations

Happy coding!
