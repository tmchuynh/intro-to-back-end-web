import BackToTop from "@/components/BackToTop";

# Git and GitHub

## Table of Contents

- [Introduction](#introduction)
- [GitHub](#github)
  - [Account Types](#account-types)
    - [User Accounts](#user-accounts)
      - [Personal Accounts](#personal-accounts)
      - [Managed User Accounts](#managed-user-accounts)
    - [Organization Accounts](#organization-accounts)
- [Git](#git)
  - [Understanding Version Control Systems](#understanding-version-control-systems)
  - [Distributed Version Control Advantages](#distributed-version-control-advantages)
  - [Essential Git Commands](#essential-git-commands)
  - [Practical Git Workflows](#practical-git-workflows)
  - [Git Branching Strategies](#git-branching-strategies)
  - [Advanced Git Concepts](#advanced-git-concepts)
  - [Git Best Practices](#git-best-practices)
  - [Common Git Scenarios](#common-git-scenarios)
  - [Troubleshooting Common Issues](#troubleshooting-common-issues)
- [GitHub Features and Tools](#github-features-and-tools)
  - [Pull Requests](#pull-requests)
  - [Issues and Project Management](#issues-and-project-management)
  - [GitHub Actions](#github-actions)
  - [Security Features](#security-features)
- [Integration and Collaboration](#integration-and-collaboration)
- [Learning Resources](#learning-resources)
- [Next Steps](#next-steps)

## Introduction

Git is a powerful distributed version control system that revolutionizes how developers collaborate on projects. Unlike traditional systems, Git enables multiple team members to work simultaneously on the same codebase without conflicts, automatically tracking every change made to the source code. This makes Git indispensable for modern software development, providing a complete history of project evolution and seamless collaboration capabilities.

GitHub serves as the world's leading platform for hosting Git repositories in the cloud. Built on Git's foundation, GitHub extends version control with intuitive web interfaces, advanced collaboration tools, and project management features. It transforms code repositories into collaborative workspaces where developers can share projects, review code, track issues, and coordinate development efforts across teams and organizations.

## GitHub

GitHub transforms code development into a collaborative experience. As a cloud-based platform, it serves as the central hub where developers store, share, and build software together. When you create a "repository" on GitHub, you unlock powerful capabilities:

- **Showcase your work** – Display your projects and contributions to the developer community
- **Version management** – Maintain a complete timeline of code changes with detailed history
- **Code review process** – Enable peer feedback and quality assurance through structured reviews
- **Safe collaboration** – Work on shared projects with confidence, knowing your changes are isolated until ready for integration

GitHub's strength lies in making Git's powerful version control accessible through an intuitive interface. The platform seamlessly integrates features like pull requests for code review, issue tracking for project management, and team coordination tools that streamline the entire development lifecycle.

The foundation of GitHub's collaborative power rests on Git, the open-source version control system that manages code changes intelligently. GitHub enhances this with user-friendly tools that make complex version control operations simple and visual. Whether you're working solo or with a global team, GitHub provides the infrastructure to organize, control, and scale your development efforts effectively. Understanding GitHub's account structure is essential for effective collaboration:

### Account Types

#### User Accounts

Every person who uses GitHub signs in to a user account. An organization account enhances collaboration between multiple users, and an enterprise account allows central management of multiple organizations. Your user account can own resources such as repositories, packages, and projects. Any time you take any action on GitHub, such as creating an issue or reviewing a pull request, the action is attributed to your user account. User accounts are intended for humans, but you can create accounts to automate activity on GitHub. This type of account is called a machine user. For example, you can create a machine user account to automate continuous integration (CI) workflows. There are two types of user account:

##### Personal accounts

If you signed up for your own account on GitHub.com, you are using a [personal account](https://docs.github.com/en/get-started/learning-about-github/types-of-github-accounts#personal-accounts).

Each personal account uses either GitHub Free or GitHub Pro. All personal accounts can own an unlimited number of public and private repositories, with an unlimited number of collaborators on those repositories. If you use GitHub Free, private repositories owned by your personal account have a limited feature set. You can upgrade to GitHub Pro to get a full feature set for private repositories. For more information, see [GitHub’s plans](https://docs.github.com/en/get-started/learning-about-github/githubs-plans). Many people use one personal account for all their work on GitHub.com, including both open source projects and paid employment. If you're currently using more than one personal account that you created for yourself, we suggest combining the accounts. For more information, see [Merging multiple personal accounts](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-your-personal-account/merging-multiple-personal-accounts). Even if you're a member of an organization that uses SAML single sign-on, you will still sign in to your own personal account on GitHub.com, and that personal account will be linked to your identity in your organization's identity provider (IdP). For more information, see [About authentication with SAML single sign-on](https://docs.github.com/en/enterprise-cloud@latest/authentication/authenticating-with-saml-single-sign-on/about-authentication-with-saml-single-sign-on)" in the GitHub Enterprise Cloud documentation.

##### Managed user accounts

If your account was created for you by an enterprise on GitHub Enterprise Cloud, you are using a [managed user account](https://docs.github.com/en/get-started/learning-about-github/types-of-github-accounts#managed-user-accounts).

As a managed user account:

- Some of your account details and settings are managed by your enterprise.
- You must sign in to your managed user account to access organizations and repositories owned by the enterprise.
- You can create your own private repositories, but you cannot create public content or contribute to repositories outside the enterprise.

#### Organization Accounts

Organization accounts enable large-scale collaboration by bringing together multiple developers under a shared workspace. Unlike individual user accounts, organizations serve as collaborative hubs where teams can coordinate across numerous projects simultaneously.

**Key features of organization accounts:**

- **Shared ownership** – Organizations can own repositories, packages, and projects that belong to the entire team rather than individuals
- **Role-based access** – Members receive different permission levels based on their responsibilities and project needs
- **Team structure** – Create nested teams that mirror your organizational hierarchy and simplify permission management
- **Advanced security** – Access sophisticated security features, administrative controls, and audit capabilities

Organizations operate through individual user accounts—you never sign in directly as an organization. Instead, each team member uses their personal account, and all actions on organizational resources are attributed to their individual identity. This approach maintains accountability while enabling seamless collaboration.

**Organizational roles provide granular control:**

- **Members** can collaborate on repositories and contribute to projects
- **Organization owners** have full administrative access and can manage all settings
- **Security managers** can control security policies and access to sensitive data

For detailed information about roles and permissions, see [Roles in an organization](https://docs.github.com/en/organizations/managing-peoples-access-to-your-organization-with-roles/roles-in-an-organization) and [Keeping your organization secure](https://docs.github.com/en/organizations/keeping-your-organization-secure).

**Team management:** Organizations support nested sub-groups called teams that reflect your company structure and streamline access management. Teams can be organized by department, project, or any logical grouping that suits your workflow. Learn more about [team organization](https://docs.github.com/en/organizations/organizing-members-into-teams/about-teams).

**Pricing options:** Organizations start with GitHub Free, which includes essential collaboration features with some limitations on private repositories. For full functionality, consider upgrading to GitHub Team or GitHub Enterprise Cloud, which unlock advanced features like SAML single sign-on, enhanced security controls, and priority support coverage.

## Git

Git revolutionizes software development by providing intelligent change tracking that enables seamless collaboration. When multiple developers work on the same files simultaneously, Git ensures that everyone's contributions integrate smoothly without conflicts or data loss.

**The Git workflow follows a proven pattern:**

- **Branch creation** – Start with an independent copy of the main codebase for your specific changes
- **Safe editing** – Make modifications on your personal branch without affecting others' work
- **Intelligent merging** – Let Git automatically combine your changes with the main codebase
- **Change tracking** – Maintain a complete history so everyone works with the most current version

### Understanding Version Control Systems

Version Control Systems (VCS) serve as the backbone of collaborative software development by maintaining a complete history of project changes. As teams work together, every modification is recorded, creating a transparent timeline that can be reviewed and restored at any point.

**VCS capabilities answer critical questions:**

- **What changed?** – Detailed records of every modification made to the codebase
- **Who made changes?** – Attribution tracking for accountability and collaboration
- **When did changes occur?** – Timestamps for understanding project evolution
- **Why were changes necessary?** – Context and reasoning behind each modification

This transparency creates a unified view of the project that keeps team members aligned while working independently. Everyone can see work in progress, understand how their contributions fit into the bigger picture, and make informed decisions based on the project's complete history.

### Distributed Version Control Advantages

Git operates as a Distributed Version Control System (DVCS), meaning every developer maintains a complete copy of the project and its entire history locally. This architecture provides significant advantages over traditional centralized systems:

**Key benefits of Git's distributed approach:**

- **Complete autonomy** – Developers can work offline and have full access to project history without server connectivity
- **Global collaboration** – Teams across different time zones can work simultaneously while maintaining code integrity
- **Branching flexibility** – Safe experimentation and feature development through isolated branches
- **Business alignment** – Break down communication barriers and enable expert collaboration across organizations

**Repository structure:** A Git repository contains your entire project—all files, folders, and revision history. This history appears as snapshots called commits, which can be organized into multiple development lines called branches. Since every repository copy is self-contained, developers can clone, branch, commit, merge, and compare changes using command-line tools or applications like GitHub Desktop.

Git's integration with platforms like GitHub extends these capabilities, enabling public repositories that promote transparency and collaborative development of high-quality software.

### Essential Git Commands

Git provides a comprehensive set of commands for managing code changes and collaboration. These commands can be executed through the command line or user-friendly applications like GitHub Desktop. Understanding these fundamental commands is crucial for effective version control:

**Repository Management:**

- `git init` – **Initialize a new repository** in an existing directory, creating the hidden `.git` folder that contains all version control data structures
- `git clone` – **Download a remote repository** to your local machine, including complete project history, files, and all branches

**Change Management:**

- `git add` – **Stage changes** for the next commit by selecting which modifications should be included in the project history
- `git commit` – **Save staged changes** as a permanent snapshot in the project timeline with a descriptive message
- `git status` – **Check current state** of your working directory, showing untracked, modified, and staged files

**Branch Operations:**

- `git branch` – **List and manage branches** in your local repository, showing all development lines
- `git merge` – **Combine branch changes** by integrating modifications from one branch into another

**Collaboration Commands:**

- `git pull` – **Sync with remote changes** by downloading and integrating teammates' commits into your local branch
- `git push` – **Upload local commits** to the remote repository, sharing your changes with the team

**The two-step commit process** (staging with `git add`, then committing with `git commit`) gives developers precise control over their project history. This separation allows you to review changes before permanently adding them to the timeline.

More Git commands can be found in the [official Git documentation](https://git-scm.com/docs) and the [GitHub CLI documentation](https://cli.github.com/manual/). There is also a Git cheat sheet available for quick reference: [Git Cheat Sheet](https://education.github.com/git-cheat-sheet-education.pdf).

### Practical Git Workflows

These examples demonstrate common Git workflows that you'll use in real development scenarios:

#### Collaborating on an Existing Project

```bash title="Working with an existing repository"
# Download the repository to your local machine
# Replace 'owner/repo' with the actual repository details
git clone https://github.com/owner/repo.git

# Navigate into the project directory
cd repo

# Create a feature branch for your changes
git branch feature/my-new-feature

# Switch to your new branch
git checkout feature/my-new-feature

# Make your changes using your preferred editor
# For example: edit README.md, update config files, add new features

# Check which files have been modified
git status

# Stage your changes for commit
git add README.md config.json

# Create a commit with a descriptive message
git commit -m "Add user authentication feature and update documentation"

# Push your branch to GitHub for collaboration
git push --set-upstream origin feature/my-new-feature
```

#### Starting a New Project

```bash title="Creating a repository from scratch"
# Create a new project directory
mkdir my-new-project
cd my-new-project

# Initialize Git version control
git init

# Create your initial project files
touch README.md package.json

# Stage all new files
git add .

# Create your first commit
git commit -m "Initial project setup with README and package configuration"

# Connect to a remote repository (create one on GitHub first)
git remote add origin https://github.com/YOUR-USERNAME/my-new-project.git

# Push your code to GitHub
git push --set-upstream origin main
```

#### Updating Your Local Work

```bash title="Staying synchronized with team changes"
# Navigate to your project directory
cd my-project

# Download the latest changes from all team members
git pull origin main

# Switch to your feature branch (if working on one)
git checkout feature/my-feature

# Continue working on your changes
# Edit files as needed...

# Stage and commit your updates
git add modified-file.js
git commit -m "Implement user validation logic"

# Share your latest changes
git push origin feature/my-feature
```

**Pro tip:** Always pull the latest changes before starting new work to avoid merge conflicts and ensure you're building on the most current codebase.

For comprehensive Git documentation and advanced commands, visit the [official Git reference](https://git-scm.com/docs).

## Git Branching Strategies

Effective branching strategies are crucial for team collaboration and maintaining code quality. Different strategies suit different team sizes and project requirements.

#### Git Flow

Git Flow is a comprehensive branching model designed for projects with scheduled releases:

```bash title="Git Flow workflow"
# Initialize git flow in your repository
git flow init

# Start a new feature
git flow feature start user-authentication

# Work on your feature
# Make commits as usual...
git add .
git commit -m "Implement login functionality"

# Finish the feature (merges to develop)
git flow feature finish user-authentication

# Create a release branch
git flow release start v1.2.0

# Make final adjustments for release
git add .
git commit -m "Update version numbers"

# Finish the release (merges to main and develop)
git flow release finish v1.2.0

# Handle hotfixes on production
git flow hotfix start critical-bug-fix
git add .
git commit -m "Fix critical security vulnerability"
git flow hotfix finish critical-bug-fix
```

**Git Flow branch structure:**
- **main** – Production-ready code
- **develop** – Integration branch for features
- **feature/** – Individual feature development
- **release/** – Preparation for production releases
- **hotfix/** – Emergency fixes for production

#### GitHub Flow

GitHub Flow offers a simplified workflow ideal for continuous deployment:

```bash title="GitHub Flow workflow"
# Create and switch to a feature branch
git checkout -b feature/payment-integration

# Make your changes and commit regularly
git add payment-gateway.js
git commit -m "Add Stripe payment integration"

git add tests/payment.test.js
git commit -m "Add payment integration tests"

# Push your branch to GitHub
git push origin feature/payment-integration

# Create a Pull Request on GitHub
# After review and approval, merge via GitHub interface

# Clean up local branch after merge
git checkout main
git pull origin main
git branch -d feature/payment-integration
```

**GitHub Flow principles:**
- **main** branch is always deployable
- Feature branches created from main
- Regular commits with descriptive messages
- Pull Requests for code review
- Deploy immediately after merge

#### Feature Branch Workflow

A flexible approach suitable for teams of any size:

```bash title="Feature branch workflow"
# Update your main branch
git checkout main
git pull origin main

# Create a descriptive feature branch
git checkout -b feature/user-profile-page

# Develop your feature with atomic commits
git add components/UserProfile.jsx
git commit -m "Create UserProfile component with basic layout"

git add styles/profile.css
git commit -m "Add responsive styling for user profile"

git add api/user-api.js
git commit -m "Implement user data fetching API"

# Push your completed feature
git push origin feature/user-profile-page

# Create Pull Request for team review
# Merge after approval and testing
```

## Advanced Git Concepts

Understanding these advanced concepts will make you more effective with Git and help you handle complex scenarios.

#### Rebasing vs. Merging

**Merging** preserves history but creates merge commits:

```bash title="Merge workflow"
# Switch to main branch
git checkout main
git pull origin main

# Merge your feature branch
git merge feature/new-dashboard

# Results in a merge commit that shows branch integration
# History: A-B-C-D-M (where M is merge commit)
```

**Rebasing** creates a linear history:

```bash title="Rebase workflow"
# Switch to your feature branch
git checkout feature/new-dashboard

# Rebase onto latest main
git rebase main

# Results in linear history
# History: A-B-C-D-E-F (no merge commit)

# Force push after rebase (be careful!)
git push --force-with-lease origin feature/new-dashboard
```

**When to use each:**
- **Merge** for feature integration and public branches
- **Rebase** for cleaning up private branch history before sharing

#### Interactive Rebasing

Clean up your commit history before sharing:

```bash title="Interactive rebase"
# Rebase last 3 commits interactively
git rebase -i HEAD~3

# This opens an editor with options:
# pick a1b2c3d Add user authentication
# squash d4e5f6g Fix authentication bug
# reword g7h8i9j Implement logout feature

# Result: Clean, meaningful commit history
```

**Rebase options:**
- **pick** – Keep commit as-is
- **squash** – Combine with previous commit
- **reword** – Change commit message
- **drop** – Remove commit entirely

#### Cherry-picking

Apply specific commits to different branches:

```bash title="Cherry-picking commits"
# Switch to target branch
git checkout hotfix/security-update

# Apply specific commit from another branch
git cherry-pick a1b2c3d

# Apply multiple commits
git cherry-pick a1b2c3d..f6g7h8i

# Cherry-pick with conflict resolution
git cherry-pick a1b2c3d
# Resolve conflicts, then:
git cherry-pick --continue
```

#### Stashing Changes

Temporarily save work without committing:

```bash title="Git stash workflow"
# Save current changes
git stash

# Save with descriptive message
git stash push -m "Work in progress on user settings"

# List all stashes
git stash list

# Apply most recent stash
git stash pop

# Apply specific stash without removing it
git stash apply stash@{2}

# Clear all stashes
git stash clear
```

## Git Best Practices

To make the most of Git's capabilities and ensure a smooth collaborative experience, consider these best practices:

- **Commit often, commit early:** Frequent commits with clear messages create a detailed project history and make it easier to track changes.
- **Use branches strategically:** Leverage branches for new features, bug fixes, and experiments to keep the main codebase stable.
- **Write meaningful commit messages:** Clear and descriptive messages provide context for your changes and help collaborators understand your intentions.
- **Keep your branches up to date:** Regularly pull changes from the main branch into your feature branches to minimize merge conflicts.
- **Review changes before merging:** Always review code changes, either through pull requests or local diffs, to maintain code quality and consistency.

Following these best practices will improve your workflow efficiency and contribute to a healthier, more manageable project repository.

## Common Git Scenarios

Here are some common scenarios you may encounter while using Git, along with solutions to address them:

- **Undoing local changes:** Use `git checkout -- <file>` to discard changes in your working directory, or `git reset HEAD <file>` to unstage changes.
- **Recovering deleted branches:** If you accidentally delete a branch, you can recover it using `git reflog` to find the commit reference and `git checkout -b <branch> <commit>` to restore it.
- **Resolving merge conflicts:** Git will highlight conflicts in the affected files. Edit the files to resolve the conflicts, then stage and commit the changes.
- **Viewing project history:** Use `git log` to view the commit history, or `git blame <file>` to see line-by-line changes and authorship information.

Familiarizing yourself with these common scenarios and their solutions will help you navigate Git more confidently and effectively.

## Troubleshooting Common Issues

Encountering issues while using Git is normal, but knowing how to troubleshoot common problems can save you time and frustration:

- **Authentication failures:** Ensure your SSH keys are correctly configured, or use a personal access token if you're prompted for a password.
- **Merge conflicts:** Resolve conflicts manually by editing the affected files, then stage and commit the changes.
- **Detached HEAD state:** If you find yourself in a detached HEAD state, you can create a new branch from your current commit using `git checkout -b <new-branch>`.

For more complex issues, consult the [official Git documentation](https://git-scm.com/doc) or seek assistance from the Git community.

## GitHub Features and Tools

GitHub offers a rich set of features and tools that enhance the development workflow and facilitate collaboration:

### Pull Requests

Pull requests are at the heart of GitHub's collaboration model. They provide a structured way to propose, discuss, and review changes before integrating them into the main codebase.

**Key aspects of pull requests:**

- **Code review:** Pull requests enable team members to review and comment on code changes, ensuring quality and consistency.
- **Continuous integration:** Automated tests and checks can be configured to run on pull requests, providing immediate feedback on the impact of changes.
- **Merge options:** GitHub offers various merge options, including merge commits, squashing, and rebasing, to accommodate different workflow preferences.

### Issues and Project Management

GitHub's issue tracking and project management features help teams plan, prioritize, and discuss work:

- **Issues:** Use issues to track bugs, enhancements, and tasks. They can be organized with labels, milestones, and assignees.
- **Projects:** GitHub Projects provide a flexible way to manage and visualize work using boards, lists, and cards.
- **Automation:** GitHub Actions can automate workflows, such as updating issues or deploying code, based on triggers and events.

### GitHub Actions

GitHub Actions is a powerful feature that enables automation of workflows directly within your GitHub repository:

- **CI/CD:** Automate your build, test, and deployment processes with continuous integration and continuous deployment (CI/CD) pipelines.
- **Custom workflows:** Create custom workflows that respond to repository events, such as pull requests, issues, and releases.
- **Marketplace:** Explore the GitHub Marketplace for pre-built actions and workflows that can be easily integrated into your projects.

### Security Features

GitHub provides a range of security features to help protect your code and manage access:

- **Branch protection rules:** Enforce policies for pull requests, such as requiring reviews or passing status checks before merging.
- **Code scanning:** Automatically scan your code for vulnerabilities and receive alerts about potential security issues.
- **Secret management:** Securely store and manage sensitive information, such as API keys and passwords, using GitHub Secrets.

## Integration and Collaboration

GitHub's integration capabilities and collaborative features make it a central hub for modern software development:

- **Third-party integrations:** Connect GitHub with other tools and services, such as project management software, communication platforms, and cloud providers.
- **Webhooks:** Configure webhooks to receive real-time notifications about repository events, enabling custom integrations and automation.
- **Collaborative coding:** Use GitHub Codespaces to create and share cloud-based development environments that include your code, dependencies, and tools.

## Learning Resources

To further enhance your Git and GitHub skills, explore these learning resources:

- **GitHub Learning Lab:** Interactive courses and tutorials on Git, GitHub, and other development topics.
- **Pro Git book:** A comprehensive guide to Git, available for free online.
- **GitHub Docs:** The official documentation for GitHub, covering all aspects of the platform.

## Next Steps

### Immediate Actions

| Priority   | Action                                                                                                               | Purpose                                                          |
| ---------- | -------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| **High**   | [Set up a Package Manager](/db-database-starter-kit/package-managers)                                                | Essential tooling for project management and dependency handling |
| **High**   | [Set up development environment](/db-environment-setup)                                                              | Essential to be able to run the code examples in this course     |
| **Medium** | [Getting Started with a Database Client](/db-database-starter-kit/database-clients)                                  | Essential tooling for database interaction                       |
| **Low**    | [Explore specific database categories](/db-different-databases-and-their-foundational-concepts/relational-databases) | Getting familiar with relational databases and others            |

### Optional Actions

| Action                                                                                                            | Purpose         |
| ----------------------------------------------------------------------------------------------------------------- | --------------- |
| [Explore Git and GitHub Tools and Resources](/db-version-control-fundamentals/git-and-GitHub-tools-and-resources) | Practical tools |

<BackToTop />
